{# markets.twig.html #}
{% extends "partials/base.twig" %}
{% import 'partials/macros.twig' as macros %}

{% block config %}
  {{ parent() }}

  {% if ENV == 'development' %}
    {% set page = page|merge(
      {
        app: true,
        classes: 'is-markets',
        search_on_page: true,
        styles: 'markets.css',
      }
    ) %}
    {% set user = user|merge({id: 1}) %}

    {# Начальное поле сортировки #}
    {% set initial_sort_field = 'rating' %}

    {# Начальное направление #}
    {% set initial_sort_direction = 'asc' %}

    {% set api_url = '/assets/data/fixtures/crypto-data.json' %}
  {% else %}
    {% set api_url = 'https://cryptoapi.ai/json/trindxrating' %}
  {% endif %}

  {# Определяем колонки здесь, чтобы можно было управлять ими из Twig, если понадобится.
  JS будет использовать этот же набор по умолчанию, но сможет его переопределить.
  Первая и последняя колонки скрыты, пока не готов функционал: `visible: false` #}

  {% set default_columns = [
    {key: 'watchlist', type: 'action', label: 'Watchlist', sortable: false, visible: false},
    {key: 'asset', type: 'text', label: 'Asset', sortable: true},
    {key: 'price', type: 'num', label: 'Price, $', sortable: true},
    {key: 'change_24h', type: 'num', label: 'Chg (24H), %', sortable: true},
    {key: 'rating', type: 'num', label: 'Rating', sortable: true},
    {key: 'risk', type: 'icon', label: 'Risk', sortable: false},
    {key: 'trindex', type: 'num', label: 'TRIndex', sortable: true},
    {key: 'rsi', type: 'num', label: 'RSI (7D)', sortable: true},
    {key: 'chart', type: 'action', label: 'Chart', sortable: false, visible: true}
  ] %}

{% endblock %}

{# {% block head %}{% endblock %} #}

{% block content %}
  {% set visible_columns_count = 0 %}
  {% for col_def in default_columns %}
    {% if col_def.visible is not defined or col_def.visible is not same as(false) %}
      {% set visible_columns_count = visible_columns_count + 1 %}
    {% endif %}
  {% endfor %}

  <div class="e-container">

    <header class="e-main__header">
      <h1>{{ 'Markets'|trans }}. <span class="text-2ry">{{ 'Asset Ranking'|trans }}</span></h1>
      {# Фильтры пока не реализованы, но кнопка остается как плейсхолдер #}
      <div role="status" aria-live="polite">
        <button class="e-btn is-tag has-start-icon" type="button" data-role="drawer-toggle" data-target="drawer-filter">
          {% include 'partials/icon.twig' with {name: 'filter'} %}
          {{ 'Filters'|trans }} 0
        </button>
      </div>
    </header>

    <div class="e-scroller is-2-directions" id="virtual-scroll-container">
      <table
        class="table has-hovered-rows has-2-liners"
        id="crypto-table" data-sort-field="{{ initial_sort_field }}"
        data-sort-direction="{{ initial_sort_direction }}"
        aria-live="polite"
        aria-busy="true"
      >
        <caption class="visually-hidden">{{ 'Cryptocurrency Market Data Table'|trans }}</caption>
        <thead>
          <tr>
            {# Генерируем заголовки на основе конфигурации колонок #}
            {% for col in default_columns %}
              {% if col.visible is not defined or col.visible is not same as(false) %}
                {% set label = col.label|trans %}
                <th class="table__cell is-{{ col.type }}{{ col.key == 'watchlist' or col.key == 'chart' ? ' is-action' : '' }}" scope="col" {% if col.type == 'action' or col.type == 'icon' %} aria-label="{{ label }}" {% endif %}>
                  {% if col.sortable %}
                    <button
                      class="e-btn is-sort {{ initial_sort_field == col.key ? 'is-active' : '' }} {{ initial_sort_field == col.key and initial_sort_direction == 'desc' ? 'is-desc' : '' }}"
                      type="button"
                      data-sort-field="{{ col.key }}"
                      aria-label="{{ 'Sort by this column'|trans }}" {# Это общая фраза, переводится нормально #}
                      aria-sort="{{ initial_sort_field == col.key ? (initial_sort_direction == 'asc' ? 'ascending' : 'descending') : 'none' }}"
                    >
                      {{ label }}
                      {% include 'partials/icon.twig' with {name: 'up'} %}
                    </button>
                  {% else %}
                    {# Не сортируемая колонка #}
                    {{ label }}
                  {% endif %}
                </th>
              {% endif %}
            {% endfor %}
          </tr>
        </thead>

        <tbody id="crypto-table-body">
          {# Начальное состояние - Загрузка #}
          <tr id="loading-row">
            <td class="table__cell is-loading-state" colspan="{{ visible_columns_count }}"> {# Теперь visible_columns_count должен быть доступен и равен 7 #}
              <p>{{ 'Loading data...'|trans }}</p>
            </td>
          </tr>
          {# Сюда JS будет вставлять строки или сообщение "Нет данных" #}
        </tbody>
      </table>
    </div>

    <!-- Скрытое уведомление для Screen Readers -->
    <div class="visually-hidden" aria-live="polite" id="screen-reader-announcement"></div>

  </div>
{% endblock %}

{% block body_suffix %}
  {# Выдвижная панель графика #}
  <dialog class="e-drawer is-bottom e-asset-details" id="drawer-chart">
    <header class=" e-drawer__header e-asset-details__header">
      <img class="e-asset-details__icon" src="" alt=""> {# src и alt будут установлены JS #}
      <span class="e-asset-details__icon-fallback e-asset__icon-fallback" aria-hidden="true"></span>
      <div class="e-asset-details__summary">
        <div class="e-row">
          <p class="e-asset-details__title tablet:d-none" aria-hidden="true"></p>
          <h2 class="e-asset-details__symbol"></h2>
          <div class="e-asset-details__price"> <small class="e-asset-details__price-change is-positive"></small></div>
        </div>
        <div class="e-row">
          <p class="e-asset-details__title d-none tablet:d-block" aria-hidden="true"></p>
          <div class="e-asset-details__stats">
            <span>{{ 'O:'|trans }} <span class="nobr" data-stat="open"></span></span>
            <span>{{ 'Min:'|trans }} <span class="nobr" data-stat="min"></span></span>
            <span>{{ 'Max:'|trans }} <span class="nobr" data-stat="max"></span></span>
          </div>
        </div>
      </div>
      <button class="e-btn is-close" type="button" data-role="close-drawer" aria-label="{{ 'Close'|trans }}">
        {% include 'partials/icon.twig' with {name: 'sm-x-mark', classes: 'is-sm', assets_prefix: assets_prefix} %}
      </button>
    </header>

    <div class="e-drawer__content">
      <div class="e-drawer__chart" id="asset-chart"></div>

      <div class="e-asset-details__period">
        {% set chart_periods = [
          {label: '1 Day', value: '1d', shortcut: '1D', checked: true},
          {label: '48–24h Ago', value: '1pd', shortcut: 'D-2'},
          {label: '1 Month', value: '1M', shortcut: '1M'},
          {label: '60–30d Ago', value: '1pM', shortcut: 'M-2'},
          {label: '1 Year', value: '1Y', shortcut: '1Y'},
          {label: '730–365d Ago', value: '1pY', shortcut: 'Y-2'}
        ] %}

        {% set chart_timeframes = [
          {label: '1 Minute', value: '1m', shortcut: '1m', checked: true},
          {label: '5 Minutes', value: '5m', shortcut: '5m'},
          {label: '15 Minutes', value: '15m', shortcut: '15m'},
          {label: '1 Hour', value: '1h', shortcut: '1H'},
          {label: '4 Hours', value: '4h', shortcut: '4H', disabled: true},
          {label: '12 Hours', value: '12h', shortcut: '12H', disabled: true},
          {label: '1 Day', value: '1d', shortcut: '1d', disabled: true}
        ] %}

        {{ macros.chart_menu('chart-period', chart_periods, '1D', 'Period') }}
        {{ macros.chart_menu('chart-timeframe', chart_timeframes, '1m', 'Timeframe') }}
      </div>
    </div>
  </dialog>

  <dialog class="e-drawer is-end" id="drawer-filter">
    <div class="e-drawer__header">
      <h2 class="e-h3">{{ 'Filters'|trans }}</h2>
    </div>

    <div class="e-drawer__content">
      <form class="e-form" id="filters-form">
        {# Диапазон цены #}
        <fieldset>
          <legend class="e-label mb-xs">{{ 'Price'|trans }}:</legend>
          <div class="e-form__row phone:2-columns">
            <div>
              <label class="e-label visually-hidden" for="filter-price-min">{{ 'From'|trans }}</label>
              <input id="filter-price-min" name="filter-price-min" type="number" step="any" min="0" placeholder="{{ 'From'|trans }}">
            </div>
            <div>
              <label class="e-label visually-hidden" for="filter-price-max">{{ 'To'|trans }}</label>
              <input id="filter-price-max" name="filter-price-max" type="number" step="any" min="0" placeholder="{{ 'To'|trans }}">
            </div>
          </div>
        </fieldset>

        {# RSI (7 дней) #}
        <fieldset>
          <legend class="e-label mb-xs">{{ 'RSI (7D)'|trans }}:</legend>
          <div class="e-form__row phone:2-columns">
            <div>
              <label class="e-label visually-hidden" for="filter-rsi-min">RSI {{ 'From'|trans }}</label>
              <input id="filter-rsi-min" name="filter-rsi-min" type="number" min="0" max="100" placeholder="{{ 'From'|trans }}">
            </div>
            <div>
              <label class="e-label visually-hidden" for="filter-rsi-max">RSI {{ 'To'|trans }}</label>
              <input id="filter-rsi-max" name="filter-rsi-max" type="number" min="0" max="100" placeholder="{{ 'To'|trans }}">
            </div>
          </div>
        </fieldset>

        {# Рейтинг #}
        <div class="mb-2">
          <label class="e-label" for="filter-rating-max">{{ 'Rating'|trans }}:</label>
          <input class="w-full" id="filter-rating-max" name="filter-rating-max" type="number" min="1" placeholder="{{ 'E.g.,'|trans }} 50">
        </div>

        {# Риск #}
        <div class="mb-2">
          <label class="e-label" for="filter-risk">{{ 'Risk Level'|trans }}</label>
          <select id="filter-risk" name="filter-risk" class="w-full">
            <option value="">{{ 'Any'|trans }}</option>
            <option value="low">{{ 'Low'|trans }}</option>
            <option value="medium">{{ 'Medium'|trans }}</option> {# Предполагаем, что API "neutral" это medium #}
            <option value="high">{{ 'High'|trans }}</option>
          </select>
        </div>

        {# Columns #}
        <fieldset>
            <legend class="e-h4 mt-2l mb-s">{{ 'Columns'|trans }}</legend>
            <ul class="e-list is-unstyled" id="filter-columns-list">
              {# Сюда JS будет вставлять чекбоксы для колонок.
                 Можно и в Twig, но для динамического управления из JS так проще.
                 Для примера, как это могло бы выглядеть в Twig:
              {% for col_conf in default_columns %}
                {% set fixed_columns = ['asset', 'price'] %}
                <li>
                  <label>
                    <input
                      type="checkbox"
                      name="column-{{ col_conf.key }}"
                      value="{{ col_conf.key }}"
                      {% if col_conf.key in fixed_columns %}checked disabled{% elseif col_conf.visible is not defined or col_conf.visible %}checked{% endif %}
                    >
                    {{ col_conf.label|trans }}
                  </label>
                </li>
              {% endfor %}
              #}
            </ul>
        </fieldset>
      </form>
    </div>
    <div class="e-drawer__footer sticky">
      <button class="e-btn" type="button" data-role="close-drawer">
        {{ 'Cancel'|trans }}
      </button>
      <button class="e-btn is-primary" type="submit" form="filters-form">
        {{ 'Apply'|trans }}
      </button>
    </div>
  </dialog>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.9/dist/chart.umd.min.js"></script>
  {# date-fns для адаптера #}
  <script src="https://cdn.jsdelivr.net/npm/date-fns@4.1.0/cdn.min.js"></script>
  {# Адаптер для дат #}
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  {# Плагин для финансовых графиков #}
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>

  <script>
    /* eslint-disable no-use-before-define, no-console */
    (() => {
      // -----------------------------------------------------------------------
      // НАСТРОЙКИ
      // -----------------------------------------------------------------------
      // #region
      const API_URL = '{{ api_url|escape("js") }}';
      const IS_DEVELOPMENT = '{{ ENV }}' === 'development';

      // 10 секунд
      const REFRESH_INTERVAL_MS = 10000;

      // Переменная в пути к картинкам, стилям и скриптам из Twig
      const ASSETS_PATH_PREFIX = '{{ site.assets_prefix|escape("js") }}';

      // Высота строки в px для виртуализации
      const ROW_HEIGHT_ESTIMATE = 56;

      // Количество строк сверху/снизу от видимой области для рендера
      const VISIBLE_BUFFER = 5;

      const VALID_TIMEFRAMES_FOR_PERIOD = {
        '1d': ['1m', '5m', '15m', '1h'],
        '1pd': ['1m', '5m', '15m', '1h'],
        '1M': ['1h', '4h', '12h', '1d'],
        '1pM': ['1h', '4h', '12h', '1d'],
        '1Y': ['12h', '1d'],
        '1pY': ['12h', '1d'],
      };

      // Переменные для хранения текущих выбранных значений
      let currentChartTicker = null;
      let currentChartPeriod = '1d';
      let currentChartTimeframe = '1m';

      // Метаданные для криптовалют (Названия, пути к иконкам)
      // Загружаются из внешнего файла. Ключ - символ в ВЕРХНЕМ РЕГИСТРЕ
      let cryptoMeta = {};

      fetch(`${ASSETS_PATH_PREFIX}/assets/data/crypto-meta.json`)
        .then((response) => response.json())
        .then((data) => {
          cryptoMeta = data;
        })
        .catch((error) => {
          if (IS_DEVELOPMENT) {
            console.error('Failed to load crypto metadata:', error);
          }

          cryptoMeta = {
            BTC: { name: 'Bitcoin', icon: 'btc.svg' },
            ETH: { name: 'Ethereum', icon: 'eth.svg' },
            SOL: { name: 'Solana', icon: 'sol.svg' },
            AVAX: { name: 'Avalanche', icon: 'avax.svg' },
            BONK: { name: 'Bonk', icon: 'bonk.svg' },
            DOGE: { name: 'Dogecoin', icon: 'doge.svg' },
            BNB: { name: 'BNB', icon: 'bnb.svg' },
          };
        });
      // #endregion

      // -----------------------------------------------------------------------
      // КОНФИГУРАЦИЯ КОЛОНОК (Добавляем все возможные из API)
      // -----------------------------------------------------------------------
      // #region
      // `apiField` - ключ в данных API. `visible` - начальное состояние.
      // `canHide` - можно ли скрыть колонку.
      // `label` будет браться из этой конфигурации для генерации чекбоксов
      const ALL_COLUMNS_CONFIG = [
        {
          key: 'watchlist',
          type: 'action',
          label: '{{ "Watchlist"|trans|escape("js") }}',
          sortable: false,
          visible: false,
          canHide: true,
          apiField: 'watchlist',
        },
        {
          key: 'asset',
          type: 'text',
          label: '{{ "Asset"|trans|escape("js") }}',
          sortable: true,
          apiField: 'symbol',
          visible: true,
          canHide: false,
        },
        {
          key: 'price',
          type: 'num',
          label: '{{ "Price, $"|trans|escape("js") }}',
          sortable: true,
          apiField: 'price.current',
          formatter: formatPrice,
          visible: true,
          canHide: false,
        },
        {
          key: 'change_24h',
          type: 'num',
          label: '{{ "Chg (24H), %"|trans|escape("js") }}',
          sortable: true,
          apiField: 'price',
          formatter: formatChange24h,
          visible: true,
          canHide: true,
        },
        {
          key: 'rating',
          type: 'num',
          label: '{{ "Rating"|trans|escape("js") }}',
          sortable: true,
          apiField: 'rating',
          formatter: formatNullable,
          visible: true,
          canHide: true,
        },
        {
          key: 'risk',
          type: 'icon',
          label: '{{ "Risk"|trans|escape("js") }}',
          sortable: false,
          apiField: 'risk',
          formatter: formatRisk,
          visible: true,
          canHide: true,
        },
        {
          key: 'trindex',
          type: 'num',
          label: '{{ "TRIndex"|trans|escape("js") }}',
          sortable: true,
          apiField: 'TRINDX',
          formatter: formatNullable,
          visible: true,
          canHide: true,
        },
        {
          key: 'rsi_7d',
          type: 'num',
          label: '{{ "RSI (7D)"|trans|escape("js") }}',
          sortable: true,
          apiField: 'RSI7',
          formatter: formatNullable,
          visible: true,
          canHide: true,
        },
        {
          key: 'rsi_30d',
          type: 'num',
          label: '{{ "RSI (30D)"|trans|escape("js") }}',
          sortable: true,
          apiField: 'RSI30',
          formatter: formatNullable,
          visible: false,
          canHide: true,
        },
        {
          key: 'rsi_91d',
          type: 'num',
          label: '{{ "RSI (91D)"|trans|escape("js") }}',
          sortable: true,
          apiField: 'RSI91',
          formatter: formatNullable,
          visible: false,
          canHide: true,
        },
        {
          key: 'rsi_182d',
          type: 'num',
          label: '{{ "RSI (182D)"|trans|escape("js") }}',
          sortable: true,
          apiField: 'RSI182',
          formatter: formatNullable,
          visible: false,
          canHide: true,
        },
        {
          key: 'rsi_365d',
          type: 'num',
          label: '{{ "RSI (365D)"|trans|escape("js") }}',
          sortable: true,
          apiField: 'RSI365',
          formatter: formatNullable,
          visible: false,
          canHide: true,
        },
        {
          key: 'rsi_1000d',
          type: 'num',
          label: '{{ "RSI (1000D)"|trans|escape("js") }}',
          sortable: true,
          apiField: 'RSI1000',
          formatter: formatNullable,
          visible: false,
          canHide: true,
        },
        {
          key: 'market',
          type: 'text',
          label: '{{ "Market"|trans|escape("js") }}',
          sortable: true,
          apiField: 'market',
          formatter: formatNullable,
          visible: false,
          canHide: true,
        },
        {
          key: 'chart',
          type: 'action',
          label: '{{ "Chart"|trans|escape("js") }}',
          sortable: false,
          visible: true,
          canHide: true,
          apiField: 'chart_data',
        },
      ];

      // Текущая конфигурация колонок, которая будет меняться
      const columnsConfig = ALL_COLUMNS_CONFIG.map((col) => ({ ...col }));

      // Динамически обновляемые переменные на основе columnsConfig
      let visibleColumns = columnsConfig.filter((c) => c.visible);
      let visibleColumnsCount = visibleColumns.length;
      // #endregion

      // -----------------------------------------------------------------------
      // СОСТОЯНИЕ
      // -----------------------------------------------------------------------
      // #region
      let allAssets = [];

      // Отсортированный массив для рендеринга
      let sortedFilteredAssets = [];
      const sortState = {
        field: '{{ initial_sort_field|escape("js") }}',
        direction: '{{ initial_sort_direction|escape("js") }}',
      };

      // Начальное состояние фильтров
      const initialFilterState = {
        priceMin: null,
        priceMax: null,
        // Для RSI7
        rsiMin: null,
        rsiMax: null,
        // "до X", т.е. значение <= X
        ratingMax: null,
        // 'low', 'medium', 'high' или '' для всех
        risk: '',
        // visibleColumnKeys будет заполнено из columnsConfig в initFilters
      };
      const currentFilterState = JSON.parse(JSON.stringify(initialFilterState));
      currentFilterState.visibleColumnKeys = columnsConfig
        .filter((c) => c.visible)
        .map((c) => c.key);

      let updateIntervalId = null;
      let isLoading = true;
      let currentRequestController = null;
      // #endregion

      // -----------------------------------------------------------------------
      // DOM ЭЛЕМЕНТЫ
      // -----------------------------------------------------------------------
      // #region

      // Таблицa
      const loadingRow = document.getElementById('loading-row');
      const scrollContainer = document.getElementById('virtual-scroll-container');
      const table = document.getElementById('crypto-table');
      const tableBody = document.getElementById('crypto-table-body');
      const tableHead = table.querySelector('thead');

      // sortButtons будет переопределен в generateTableHeadHtml
      let sortButtons = [];
      const screenReaderAnnouncer = document.getElementById(
        'screen-reader-announcement'
      );

      // Фильтр
      const drawerFilter = document.getElementById('drawer-filter');
      const filtersForm = document.getElementById('filters-form');
      const filterColumnsList = document.getElementById('filter-columns-list');
      const filterToggleButton = document.querySelector(
        '[data-target="drawer-filter"]'
      );

      // График
      const assetChartContainer = document.getElementById('asset-chart');
      const drawerChart = document.getElementById('drawer-chart');

      // График: заголовок
      const drawerChartIcon = drawerChart?.querySelector('.e-asset-details__icon');
      const drawerChartIconFallback = drawerChart?.querySelector(
        '.e-asset-details__icon-fallback'
      );
      const drawerChartTitleElements = drawerChart?.querySelectorAll(
        '.e-asset-details__title'
      );
      const drawerChartSymbol = drawerChart?.querySelector(
        '.e-asset-details__symbol'
      );
      const drawerChartPrice = drawerChart?.querySelector(
        '.e-asset-details__price'
      );
      const drawerChartPriceChange = drawerChart?.querySelector(
        '.e-asset-details__price-change'
      );
      const drawerChartOpen = drawerChart?.querySelector(
        '.e-asset-details__stats [data-stat="open"]'
      );
      const drawerChartHigh = drawerChart?.querySelector(
        '.e-asset-details__stats [data-stat="max"]'
      );
      const drawerChartLow = drawerChart?.querySelector(
        '.e-asset-details__stats [data-stat="min"]'
      );

      // График: меню периода
      const drawerChartPeriodMenu = document.querySelector(
        '.e-asset-details__period details[data-role="popover"]:has(input[name="chart-period"])'
      );
      const drawerChartTimeframeMenu = document.querySelector(
        '.e-asset-details__period details[data-role="popover"]:has(input[name="chart-timeframe"])'
      );
      const periodRadioButtons = drawerChartPeriodMenu
        ? Array.from(
            drawerChartPeriodMenu.querySelectorAll('input[name="chart-period"]')
          )
        : [];
      const timeframeRadioButtons = drawerChartTimeframeMenu
        ? Array.from(
            drawerChartTimeframeMenu.querySelectorAll(
              'input[name="chart-timeframe"]'
            )
          )
        : [];
      // #endregion

      // -----------------------------------------------------------------------
      // ФОРМАТИРОВАНИЕ ДАННЫХ
      // -----------------------------------------------------------------------
      // #region

      function formatPrice(value) {
        if (value === null || value === undefined) return '–';
        const price = parseFloat(value);
        if (Number.isNaN(price)) return '–';
        // Для очень маленьких значений используем экспоненциальную запись
        if (price < 0.00000001 && price > 0) return price.toExponential(2);
        // Для значений меньше 1 используем до 8 знаков после запятой
        if (price < 1) {
          // Находим первую значащую цифру после запятой
          const sigDigit = (price.toString().split('.')[1] || '').search(/[^0]/);
          // Используем максимум 8 знаков, но не меньше, чем до первой значащей цифры + 2
          return price.toFixed(Math.min(8, Math.max(sigDigit + 2, 2)));
        }
        // Для больших значений оставляем 2 знака после запятой
        return price.toLocaleString('en-US', {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        });
      }

      function formatChange24h(priceData) {
        if (
          !priceData ||
          priceData.current === undefined ||
          priceData.yesterday?.middle === undefined
        )
          return '–';
        const current = parseFloat(priceData.current);
        const yesterdayMiddle = parseFloat(priceData.yesterday.middle);
        if (
          Number.isNaN(current) ||
          Number.isNaN(yesterdayMiddle) ||
          yesterdayMiddle === 0
        )
          return '–';
        const change = ((current - yesterdayMiddle) / yesterdayMiddle) * 100;
        const sign = change > 0 ? '+' : '';
        return `${sign}${change.toFixed(2)}`;
      }

      function formatRisk(value) {
        const riskLower = (value || '').toLowerCase();
        switch (riskLower) {
          case 'high': {
            return `<span class="has-tooltip" aria-label="{{ "High risk"|trans|escape("js") }}"><svg class="e-icon is-error" aria-hidden="true" focusable="false"><use xlink:href="${
              ASSETS_PATH_PREFIX
            }/assets/img/icons/sprite.svg#icon-error"></use></svg></span>`;
          }
          case 'medium':
          case 'neutral': {
            return `<span class="has-tooltip" aria-label="{{ "Medium risk"|trans|escape("js") }}"><svg class="e-icon is-yin-yang" aria-hidden="true" focusable="false"><use xlink:href="${
              ASSETS_PATH_PREFIX
            }/assets/img/icons/sprite.svg#icon-yin-yang"></use></svg></span>`;
          }
          case 'low': {
            return `<span class="has-tooltip" aria-label="{{ "Low risk"|trans|escape("js") }}"><svg class="e-icon is-success" aria-hidden="true" focusable="false"><use xlink:href="${
              ASSETS_PATH_PREFIX
            }/assets/img/icons/sprite.svg#icon-success"></use></svg></span>`;
          }
          default: {
            return '<span aria-label="{{ "No risk data"|trans|escape("js") }}">–</span>';
          }
        }
      }

      function formatNullable(value) {
        return value !== null && value !== undefined ? value : '–';
      }
      // #endregion

      // -----------------------------------------------------------------------
      // ПОЛУЧЕНИЕ И ОБРАБОТКА ДАННЫХ
      // -----------------------------------------------------------------------
      // #region

      // Функция для получения значения из вложенного объекта (например, 'price.current')
      const getNestedValue = (obj, path) => {
        if (!obj || !path) return null;
        return path.split('.').reduce((acc, part) => (acc ? acc[part] : null), obj);
      };

      // Cleanup function to clear interval
      const cleanup = () => {
        if (updateIntervalId) {
          clearInterval(updateIntervalId);
          updateIntervalId = null;
        }
      };

      /**
      * Асинхронная функция для получения котировок и индексов криптовалют через API или локальный JSON
      *
      * 1. Отменяет предыдущий незавершенный запрос, если он существует
      * 2. Формирует параметры запроса в зависимости от окружения (development/production)
      * 3. Определяет язык из URL и формирует полный URL для запроса
      * 4. Выполняет fetch-запрос и обрабатывает ответ
      * 5. В случае получения HTML вместо JSON (например, страница авторизации) перенаправляет на страницу входа
      * 6. Обрабатывает полученные данные через функцию processData
      * 7. Управляет состоянием загрузки и отображением индикатора
      * 8. Обрабатывает ошибки и отображает соответствующие сообщения
      *
      * @async
      * @throws {Error} Если запрос завершился с ошибкой или получен неверный формат данных
      * @returns {Promise<void>}
      */
      async function fetchData() {
        if (currentRequestController) {
          currentRequestController.abort();
        }
        currentRequestController = new AbortController();

        const params = new URLSearchParams();
        params.append('jsonfather', 'true');

        try {
          const options = IS_DEVELOPMENT
            ? { method: 'GET', signal: currentRequestController.signal }
            : {
                method: 'POST',
                body: params.toString(),
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                credentials: 'include',
                signal: currentRequestController.signal,
              };

          const currentLang = window.location.pathname
            .split('/')[1]
            ?.match(/^[a-z]{2}$/)
            ? window.location.pathname.split('/')[1]
            : '';
          const fullApiUrl = IS_DEVELOPMENT
            ? API_URL
            : `${window.location.origin}/${currentLang ? `${currentLang}/` : ''}json/trindxrating`;

          const response = await fetch(fullApiUrl, options);

          if (!response.ok) {
            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('text/html')) {
              window.location.href = `/auth?returl=${encodeURIComponent(window.location.pathname)}`;
              return;
            }
            throw new Error(
              `{{ "Something went wrong while loading the page."|trans|escape("js") }} status: ${response.status}`
            );
          }

          const data = await response.json();
          // Запоминаем состояние isLoading ДО processData
          const wasLoading = isLoading;

          // processData вызовет applySortAndFilter, который вызовет patchTableBody
          processData(data);

          if (wasLoading) {
            // Если это была первая загрузка; мы точно загрузились
            isLoading = false;
            table.setAttribute('aria-busy', 'false');
            // loadingRow удаляется внутри patchTableBody или displayErrorState
            announceUpdate(
              '{{ "All data has been successfully loaded."|trans|escape("js") }}'
            );
          } else {
            // Это было автообновление
            // Сохранение и восстановление скролла лучше делать вокруг patchTableBody,
            // но так как applySortAndFilter принимает флаг, он может это обработать.
            // Этот announceUpdate есть и в applySortAndFilter, если это не первая загрузка.
            // announceUpdate('{{ "Table data updated."|trans|escape("js") }}');
            // Можно оставить один из них.
            // Давайте оставим тот, что вызывается более глобально здесь.
            announceUpdate('{{ "The data has been updated."|trans|escape("js") }}');
          }
        } catch (error) {
          cleanup();
          if (error.name === 'AbortError') {
            if (IS_DEVELOPMENT) console.log('Fetch aborted');
            return;
          }
          if (IS_DEVELOPMENT) console.error('Failed to fetch crypto data:', error);

          // Важно: если ошибка при загрузке, сбрасываем isLoading
          if (isLoading) {
            isLoading = false;
            table.setAttribute('aria-busy', 'false');
          }
          displayErrorState(
            `{{ "Data couldn’t be loaded. Try again soon."|trans|escape("js") }} ${error.message}`
          );
        } finally {
          currentRequestController = null;
        }
      }

      /**
      * Обрабатывает данные, полученные от API, и подготавливает их для отображения в таблице.
      *
      * @param {Object|Array} responseData - Данные, полученные от API. В режиме разработки - объект,
      *                                     в продакшене - массив [status, data].
      *
      * @description
      * 1. Проверяет формат полученных данных в зависимости от окружения (разработка/продакшн)
      * 2. Валидирует структуру данных
      * 3. Преобразует данные в унифицированный формат для каждого криптоактива
      * 4. Добавляет метаданные (имя, иконку) из cryptoMeta
      * 5. Обрабатывает случаи с некорректными данными, предоставляя значения по умолчанию
      * 6. Обновляет UI и состояние загрузки
      * 7. Применяет сортировку и фильтрацию
      * 8. Отрисовывает таблицу
      *
      * @throws {void} Не выбрасывает исключений, но может вызвать displayErrorState при некорректных данных
      */
      const processData = (responseData) => {
        let actualCryptoDataObject;

        // Блок определения actualCryptoDataObject из responseData (как вы уже сделали)
        if (IS_DEVELOPMENT) {
          if (
            Array.isArray(responseData) &&
            responseData.length === 2 &&
            responseData[0] === 'OK' &&
            typeof responseData[1] === 'object'
          ) {
            [, actualCryptoDataObject] = responseData;
          } else if (
            typeof responseData === 'object' &&
            !Array.isArray(responseData)
          ) {
            actualCryptoDataObject = responseData;
          } else {
            if (IS_DEVELOPMENT)
              console.error(
                'Unexpected format for development data in crypto-data.json:',
                responseData
              );
            displayErrorState(
              '{{ "Invalid development data format."|trans|escape("js") }}'
            );
            return;
          }
        } else {
          if (
            !Array.isArray(responseData) ||
            responseData.length < 2 ||
            responseData[0] !== 'OK' ||
            typeof responseData[1] !== 'object' ||
            responseData[1] === null
          ) {
            if (IS_DEVELOPMENT)
              console.error(
                'Production API response format error or status not OK:',
                responseData
              );
            displayErrorState(
              '{{ "Server sent data in an unexpected format or an error status."|trans|escape("js") }}'
            );
            return;
          }
          [, actualCryptoDataObject] = responseData;
        }

        if (
          !actualCryptoDataObject ||
          typeof actualCryptoDataObject !== 'object' ||
          Array.isArray(actualCryptoDataObject)
        ) {
          if (IS_DEVELOPMENT)
            console.error(
              'actualCryptoDataObject is not a valid object after initial processing:',
              actualCryptoDataObject
            );
          displayErrorState(
            '{{ "No valid asset data available."|trans|escape("js") }}'
          );
          return;
        }

        const newApiSymbols = Object.keys(actualCryptoDataObject).map((s) =>
          // Всегда работаем с UPPERCASE символами из API
          s.toUpperCase()
        );

        // Создаем новый массив allAssets на основе текущих и новых данных
        const nextAllAssets = [];
        // Чтобы отслеживать уже обработанные символы
        const processedSymbols = new Set();

        // Сначала обновляем или сохраняем существующие активы
        allAssets.forEach((existingAsset) => {
          // Убедимся, что символ существующего актива тоже в верхнем регистре
          const upperSymbol = existingAsset.symbol.toUpperCase();
          if (newApiSymbols.includes(upperSymbol)) {
            // Если актив есть в новых данных
            const meta = cryptoMeta[upperSymbol] || {
              name: upperSymbol,
              icon: null,
            };
            const newAssetDataForSymbol =
              actualCryptoDataObject[upperSymbol] ||
              // Пытаемся найти по обоим регистрам на всякий случай
              actualCryptoDataObject[existingAsset.symbol];

            if (
              typeof newAssetDataForSymbol === 'object' &&
              newAssetDataForSymbol !== null
            ) {
              Object.assign(existingAsset, newAssetDataForSymbol, {
                name: meta.name,
                icon: meta.icon
                  ? `${ASSETS_PATH_PREFIX}/assets/img/cryptologos/${meta.icon}`
                  : null,
                symbol: upperSymbol,
              });
              nextAllAssets.push(existingAsset);
            } else if (IS_DEVELOPMENT) {
              // Новые данные для существующего актива некорректны, можно его пропустить или создать дефолтный
              // Пропустим, чтобы он удалился ниже, если его нет в newApiSymbols с корректными данными
              console.warn(
                `Incorrect new data for existing symbol ${upperSymbol}, it might be removed if not present with valid data.`
              );
            }
            processedSymbols.add(upperSymbol);
          } else if (IS_DEVELOPMENT)
            // Актив был в allAssets, но его нет в новых данных от API - он будет удален (не добавляем в nextAllAssets)
            console.log(
              `Asset ${upperSymbol} no longer in API response, will be removed.`
            );
        });

        // Добавляем полностью новые активы
        newApiSymbols.forEach((upperSymbol) => {
          if (!processedSymbols.has(upperSymbol)) {
            const meta = cryptoMeta[upperSymbol] || {
              name: upperSymbol,
              icon: null,
            };
            const assetApiData =
              actualCryptoDataObject[upperSymbol] ||
              // Пробуем оба регистра из API
              actualCryptoDataObject[upperSymbol.toLowerCase()];

            if (typeof assetApiData === 'object' && assetApiData !== null) {
              nextAllAssets.push({
                symbol: upperSymbol,
                name: meta.name,
                // Используем символ как ID, если нет другого
                id: upperSymbol,
                icon: meta.icon
                  ? `${ASSETS_PATH_PREFIX}/assets/img/cryptologos/${meta.icon}`
                  : null,
                watchlist: false,
                chart_data: [],
                // Данные из API
                ...assetApiData,
              });
            } else {
              if (IS_DEVELOPMENT)
                console.warn(
                  `Data for new symbol ${upperSymbol} is not an object or is null:`,
                  assetApiData
                );
              // Создаем дефолтный объект для нового символа с некорректными данными, чтобы он был в списке, но с прочерками
              nextAllAssets.push({
                symbol: upperSymbol,
                name: meta.name,
                id: upperSymbol,
                icon: meta.icon
                  ? `${ASSETS_PATH_PREFIX}/assets/img/cryptologos/${meta.icon}`
                  : null,
                price: {
                  current: null,
                  yesterday: { middle: null },
                  today: { min: null, max: null, middle: null },
                },
                rating: null,
                risk: null,
                TRINDX: null,
                RSI7: null /* и т.д. */,
                watchlist: false,
                chart_data: [],
              });
            }
          }
        });

        // Полностью заменяем allAssets новым сформированным списком
        allAssets = nextAllAssets;

        // isLoading сбрасывается в fetchData после успешного processData
        // Передаем isLoading (который еще true при первой загрузке)
        applySortAndFilter(isLoading);
      };

      /**
      * Отображает состояние ошибки в таблице
      * @param {string} message - Сообщение об ошибке для отображения
      * @description
      * - Вставляет строку с сообщением об ошибке в тело таблицы
      * - Добавляет кнопку повторной попытки
      * - Снимает индикатор загрузки с таблицы
      * - Скрывает строку загрузки, если она присутствует
      * - Сбрасывает флаг состояния загрузки
      */
      function displayErrorState(message) {
        tableBody.innerHTML = `
          <tr>
            <td class="table__cell is-empty-state is-error-state" colspan="${visibleColumnsCount}">
              <p>${message}</p>
              <button class="e-btn is-text" onclick="location.reload()">{{ "Retry"|trans|escape("js") }}</button>
            </td>
          </tr>`;
        // Снимаем состояние занятости при ошибке
        table.setAttribute('aria-busy', 'false');
        // Скрываем строку загрузки если она еще есть
        if (loadingRow) loadingRow.style.display = 'none';

        // Считаем загрузку завершенной (с ошибкой)
        isLoading = false;
      }
      // #endregion

      // -----------------------------------------------------------------------
      // ФИЛЬТРЫ И КОЛОНКИ
      // -----------------------------------------------------------------------
      // #region
      function populateColumnCheckboxes() {
        filterColumnsList.innerHTML = '';
        columnsConfig.forEach((col) => {
          const listItem = document.createElement('li');
          const label = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.name = 'column-filter';
          checkbox.value = col.key;
          checkbox.checked = col.visible;
          if (!col.canHide) {
            checkbox.disabled = true;
          }
          checkbox.addEventListener('change', handleColumnVisibilityChange);

          label.appendChild(checkbox);
          label.appendChild(document.createTextNode(` ${col.label}`));
          listItem.appendChild(label);
          filterColumnsList.appendChild(listItem);
        });
      }

      function handleColumnVisibilityChange(event) {
        const changedKey = event.target.value;
        const isVisible = event.target.checked;

        const columnIndex = columnsConfig.findIndex((c) => c.key === changedKey);
        if (columnIndex > -1) {
          columnsConfig[columnIndex].visible = isVisible;
        }

        // Обновляем производные переменные
        visibleColumns = columnsConfig.filter((c) => c.visible);
        visibleColumnsCount = visibleColumns.length;
        currentFilterState.visibleColumnKeys = visibleColumns.map((c) => c.key);

        // Немедленно перерисовываем заголовок и таблицу
        generateTableHeadHtml();
        applySortAndFilter(false);
        updateFilterCountBadge();
      }

      function applyFiltersAndDraw() {
        // 1. Прочитать значения из формы в currentFilterState
        currentFilterState.priceMin =
          parseFloat(filtersForm.elements['filter-price-min'].value) || null;
        currentFilterState.priceMax =
          parseFloat(filtersForm.elements['filter-price-max'].value) || null;
        currentFilterState.rsiMin =
          parseFloat(filtersForm.elements['filter-rsi-min'].value) || null;
        currentFilterState.rsiMax =
          parseFloat(filtersForm.elements['filter-rsi-max'].value) || null;
        currentFilterState.ratingMax =
          parseFloat(filtersForm.elements['filter-rating-max'].value) || null;
        currentFilterState.risk = filtersForm.elements['filter-risk'].value || '';

        // Валидация: если min > max, поменять их местами или обнулить max
        if (
          currentFilterState.priceMin &&
          currentFilterState.priceMax &&
          currentFilterState.priceMin > currentFilterState.priceMax
        ) {
          [currentFilterState.priceMin, currentFilterState.priceMax] = [
            currentFilterState.priceMax,
            currentFilterState.priceMin,
          ];
          // Обновить поля в UI
          filtersForm.elements['filter-price-min'].value =
            currentFilterState.priceMin;
          filtersForm.elements['filter-price-max'].value =
            currentFilterState.priceMax;
        }
        if (
          currentFilterState.rsiMin &&
          currentFilterState.rsiMax &&
          currentFilterState.rsiMin > currentFilterState.rsiMax
        ) {
          [currentFilterState.rsiMin, currentFilterState.rsiMax] = [
            currentFilterState.rsiMax,
            currentFilterState.rsiMin,
          ];
          filtersForm.elements['filter-rsi-min'].value = currentFilterState.rsiMin;
          filtersForm.elements['filter-rsi-max'].value = currentFilterState.rsiMax;
        }

        // 2. Применить фильтры и сортировку
        applySortAndFilter(true);

        // 3. Обновить значок счетчика
        updateFilterCountBadge();

        // 4. Закрыть панель
        if (drawerFilter.close) drawerFilter.close();
      }

      function updateFilterCountBadge() {
        let count = 0;
        if (
          currentFilterState.priceMin !== null ||
          currentFilterState.priceMax !== null
        )
          count += 1;
        if (
          currentFilterState.rsiMin !== null ||
          currentFilterState.rsiMax !== null
        )
          count += 1;
        if (currentFilterState.ratingMax !== null) count += 1;
        if (currentFilterState.risk) count += 1;

        // Считаем не дефолтные видимые колонки
        const defaultVisibleKeys = ALL_COLUMNS_CONFIG.filter((c) => c.visible).map(
          (c) => c.key
        );
        const currentVisibleKeys = columnsConfig
          .filter((c) => c.visible)
          .map((c) => c.key);
        if (
          JSON.stringify(defaultVisibleKeys.sort()) !==
          JSON.stringify(currentVisibleKeys.sort())
        ) {
          count += 1;
        }

        filterToggleButton.innerHTML = `
                                          {% include 'partials/icon.twig' with {name: 'filter'} %}
                                          {{ 'Filters'|trans }} ${count}
                                        `;
      }

      filtersForm.addEventListener('submit', (event) => {
        event.preventDefault();
        applyFiltersAndDraw();
      });
      // #endregion

      // -----------------------------------------------------------------------
      // ГЕНЕРАЦИЯ ЗАГОЛОВКА ТАБЛИЦЫ
      // -----------------------------------------------------------------------
      // #region

      function generateTableHeadHtml() {
        let headHtml = '<tr>';
        visibleColumns.forEach((col) => {
          const { label } = col;
          const thClasses = `table__cell is-${col.type}${col.key === 'watchlist' || col.key === 'chart' ? ' is-action' : ''}`;
          let thContent = label;
          let ariaLabelAttr =
            col.type === 'action' || col.type === 'icon'
              ? `aria-label="${label}"`
              : '';

          if (col.sortable) {
            const isActive = sortState.field === col.key;
            const isDesc = isActive && sortState.direction === 'desc';
            let ariaSort = 'none';
            if (isActive) {
              ariaSort = sortState.direction === 'asc' ? 'ascending' : 'descending';
            }
            thContent = `
                                              <button
                                                class="e-btn is-sort ${isActive ? 'is-active' : ''} ${isDesc ? 'is-desc' : ''}"
                                                type="button"
                                                data-sort-field="${col.key}"
                                                aria-label="{{ 'Sort by this column'|trans|escape('js') }}"
                                                aria-sort="${ariaSort}"
                                              >
                                                ${label}
                                                {% include 'partials/icon.twig' with {name: 'up'} %}
                                              </button>`;
            // aria-label на кнопке, а не на th
            ariaLabelAttr = '';
          }
          headHtml += `<th class="${thClasses}" scope="col" ${ariaLabelAttr}>${thContent}</th>`;
        });
        headHtml += '</tr>';
        tableHead.innerHTML = headHtml;

        // Переназначаем обработчики на новые кнопки сортировки
        sortButtons = tableHead.querySelectorAll(
          'thead th button[data-sort-field]'
        );
        sortButtons.forEach((button) => {
          button.addEventListener('click', handleSortClick);
        });
      }
      // #endregion

      // -----------------------------------------------------------------------
      // СОРТИРОВКА
      // -----------------------------------------------------------------------
      // #region

      function handleSortClick(event) {
        const button = event.currentTarget;
        const field = button.dataset.sortField;

        let direction = 'asc';
        if (sortState.field === field && sortState.direction === 'asc') {
          direction = 'desc';
        }

        sortState.field = field;
        sortState.direction = direction;

        // Обновляем ARIA атрибуты и классы кнопок
        sortButtons.forEach((btn) => {
          const btnField = btn.dataset.sortField;
          if (btnField === field) {
            btn.classList.add('is-active');
            btn.classList.toggle('is-desc', direction === 'desc');
            btn.setAttribute(
              'aria-sort',
              direction === 'asc' ? 'ascending' : 'descending'
            );
          } else {
            btn.classList.remove('is-active', 'is-desc');
            btn.setAttribute('aria-sort', 'none');
          }
        });

        // Пересортировать и перерисовать
        applySortAndFilter();
        announceUpdate(
          // eslint-disable-next-line prefer-template
          '{{ "Table sorted by"|trans|escape("js") }} ' +
            (columnsConfig.find((c) => c.key === field)?.label || field) +
            (direction === 'asc'
              ? ' {{ "ascending"|trans|escape("js") }}'
              : ' {{ "descending"|trans|escape("js") }}')
        );
      }

      /**
      * Применяет текущие фильтры и сортировку к allAssets, обновляет sortedFilteredAssets и перерисовывает таблицу.
      */
      function applySortAndFilter(isInitialLoadOrManualSortAction = true) {
        // Переименовал параметр для ясности
        if (!Array.isArray(allAssets)) {
          if (IS_DEVELOPMENT) console.error('allAssets is not an array');
          return;
        }

        // 1. Фильтрация
        const filteredData = allAssets.filter((asset) => {
          // Цена
          if (
            currentFilterState.priceMin !== null &&
            (asset.price?.current === null ||
              parseFloat(asset.price.current) < currentFilterState.priceMin) // parseFloat здесь
          )
            return false;
          if (
            currentFilterState.priceMax !== null &&
            (asset.price?.current === null ||
              parseFloat(asset.price.current) > currentFilterState.priceMax) // parseFloat здесь
          )
            return false;

          // RSI (7D). Используем ALL_COLUMNS_CONFIG
          const rsi7dConfig = ALL_COLUMNS_CONFIG.find((c) => c.key === 'rsi_7d');
          const rsiValue = rsi7dConfig
            ? getNestedValue(asset, rsi7dConfig.apiField)
            : null;

          if (
            currentFilterState.rsiMin !== null &&
            (rsiValue === null || parseFloat(rsiValue) < currentFilterState.rsiMin)
          )
            return false;
          if (
            currentFilterState.rsiMax !== null &&
            (rsiValue === null || parseFloat(rsiValue) > currentFilterState.rsiMax)
          )
            return false;

          // Рейтинг
          if (
            currentFilterState.ratingMax !== null &&
            (asset.rating === null || asset.rating > currentFilterState.ratingMax)
          )
            return false;

          // Риск
          if (currentFilterState.risk) {
            let assetRisk = (asset.risk || '').toLowerCase();
            if (assetRisk === 'neutral') assetRisk = 'medium';
            if (assetRisk !== currentFilterState.risk) return false;
          }
          return true;
        });

        // 2. Сортировка
        const dataToSort = [...filteredData];
        // columnsConfig для актуальной видимости
        const sortConfig = columnsConfig.find((c) => c.key === sortState.field);

        if (sortConfig && !sortConfig.visible) {
          sortState.field = 'asset';
          sortState.direction = 'asc';
          generateTableHeadHtml();
        }
        const currentSortConfig = columnsConfig.find(
          // columnsConfig для актуальной видимости
          (c) => c.key === sortState.field
        );
        const apiField = currentSortConfig?.apiField || sortState.field;

        dataToSort.sort((a, b) => {
          let valA = getNestedValue(a, apiField);
          let valB = getNestedValue(b, apiField);

          if (sortState.field === 'asset') {
            valA = a.name?.toLowerCase() || '';
            valB = b.name?.toLowerCase() || '';
          } else if (sortState.field === 'change_24h') {
            const changeA = calculateChange24hValue(a.price);
            const changeB = calculateChange24hValue(b.price);
            valA =
              changeA ?? (sortState.direction === 'asc' ? Infinity : -Infinity);
            valB =
              changeB ?? (sortState.direction === 'asc' ? Infinity : -Infinity);
          } else {
            const numA = parseFloat(valA);
            const numB = parseFloat(valB);
            if (!Number.isNaN(numA) && !Number.isNaN(numB)) {
              valA = numA;
              valB = numB;
            } else if (typeof valA === 'string' && typeof valB === 'string') {
              valA = valA.toLowerCase();
              valB = valB.toLowerCase();
            }
          }

          const aIsNull =
            valA === null ||
            valA === undefined ||
            valA === Infinity ||
            valA === -Infinity;
          const bIsNull =
            valB === null ||
            valB === undefined ||
            valB === Infinity ||
            valB === -Infinity;

          if (aIsNull && bIsNull) return 0;
          if (
            typeof valA === 'number' ||
            typeof valB === 'number' ||
            valA === Infinity ||
            valA === -Infinity ||
            valB === Infinity ||
            valB === -Infinity
          ) {
            if (aIsNull) return sortState.direction === 'asc' ? 1 : -1;
            if (bIsNull) return sortState.direction === 'asc' ? -1 : 1;
          }

          if (valA < valB) return sortState.direction === 'asc' ? -1 : 1;
          if (valA > valB) return sortState.direction === 'asc' ? 1 : -1;
          return 0;
        });

        sortedFilteredAssets = dataToSort;

        if (isInitialLoadOrManualSortAction) {
          scrollContainer.scrollTop = 0;
        }
        patchTableBody();
      }

      // Вспомогательная функция для получения числового значения изменения 24ч
      const calculateChange24hValue = (priceData) => {
        if (!priceData?.current || !priceData?.yesterday?.middle) {
          return null;
        }

        const current = parseFloat(priceData.current);
        const yesterdayMiddle = parseFloat(priceData.yesterday.middle);

        if (
          Number.isNaN(current) ||
          Number.isNaN(yesterdayMiddle) ||
          yesterdayMiddle === 0
        ) {
          return null;
        }

        return ((current - yesterdayMiddle) / yesterdayMiddle) * 100;
      };
      // #endregion

      // -----------------------------------------------------------------------
      // РЕНДЕРИНГ (ТАБЛИЦЫ
      // -----------------------------------------------------------------------
      // #region

      function generateCellsHtml(asset) {
        // Эта функция генерирует HTML только для <td> ячеек одной строки
        // Она похожа на старую generateTableRowHtml, но без обертки <tr>
        let cellsHtml = '';
        visibleColumns.forEach((col) => {
          let cellContent = '';
          let cellClasses = `table__cell is-${col.type}`;
          // Атрибуты для td, если нужны
          const attributes = '';

          switch (col.key) {
            case 'watchlist':
              // Заглушка
              cellContent = `<!-- Watchlist button for ${asset.symbol} -->`;
              cellClasses += ' is-action';
              break;
            case 'asset': {
              const iconPath = asset.icon;
              const fallbackIcon = `<span class="e-asset__icon-fallback" aria-hidden="true">${asset.symbol.substring(0, 3)}</span>`;
              const imgTag = iconPath
                ? `<img class="e-asset__icon" src="${iconPath}" alt="" loading="lazy" width="32" height="32" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';">`
                : '';
              cellContent = `
              <div class="e-asset">
                <div class="e-asset__copy">
                  <span class="e-asset__name">${asset.name}</span>
                  <span class="e-asset__symbol">${asset.symbol}</span>
                </div>
                ${imgTag}
                ${fallbackIcon}
              </div>`;
              cellClasses += ' is-2-liner';
              break;
            }
            case 'risk':
              cellContent = col.formatter(getNestedValue(asset, col.apiField));
              cellClasses += ' is-icon';
              break;
            case 'change_24h': {
              const changeValue = calculateChange24hValue(asset.price);
              if (changeValue !== null && !Number.isNaN(changeValue)) {
                // Also fixing isNaN below
                cellContent = `${changeValue > 0 ? '+' : ''}${changeValue.toFixed(2)}`;
                if (changeValue > 0) {
                  cellClasses += ' is-positive';
                } else if (changeValue < 0) {
                  cellClasses += ' is-negative';
                }
              } else {
                cellContent = '–';
              }
              break;
            }
            case 'chart': {
              const assetIdForChart = asset.id || asset.symbol;
              const assetNameForChart = asset.name || asset.symbol;
              cellContent = `
              <button class="e-btn is-chart" type="button" aria-label="{{ 'Show chart'|trans|escape('js') }}: ${assetNameForChart}"
                data-role="drawer-toggle" data-target="drawer-chart"
                data-asset-id="${assetIdForChart}" data-asset-symbol="${asset.symbol}">
                <svg class="e-icon" aria-hidden="true" focusable="false"><use xlink:href="${ASSETS_PATH_PREFIX}/assets/img/icons/sprite.svg#icon-candles"></use></svg>
              </button>`;
              cellClasses += ' is-action';
              break;
            }
            default: {
              const value = getNestedValue(asset, col.apiField);
              cellContent = col.formatter
                ? col.formatter(value)
                : formatNullable(value);
              break;
            }
          }
          cellsHtml += `<td class="${cellClasses}" ${attributes}>${cellContent}</td>`;
        });
        return cellsHtml;
      }

      function patchTableBody() {
        if (isLoading && sortedFilteredAssets.length === 0) {
          if (!document.getElementById('loading-row') && loadingRow) {
            tableBody.innerHTML = '';
            // Используем cloneNode
            tableBody.appendChild(loadingRow.cloneNode(true));
          }
          return;
        }
        if (!isLoading && document.getElementById('loading-row')) {
          // Получаем актуальный элемент
          const currentLoadingRow = document.getElementById('loading-row');
          if (currentLoadingRow) currentLoadingRow.remove();
        }

        const totalItems = sortedFilteredAssets.length;
        const { scrollTop } = scrollContainer;
        const containerHeight = scrollContainer.clientHeight;

        const startIndex = Math.max(
          0,
          Math.floor(scrollTop / ROW_HEIGHT_ESTIMATE) - VISIBLE_BUFFER
        );
        const endIndex = Math.min(
          totalItems,
          Math.ceil((scrollTop + containerHeight) / ROW_HEIGHT_ESTIMATE) +
            VISIBLE_BUFFER
        );

        const topSpacerHeight = startIndex * ROW_HEIGHT_ESTIMATE;
        const bottomSpacerHeight = (totalItems - endIndex) * ROW_HEIGHT_ESTIMATE;

        const fragment = document.createDocumentFragment();

        // 1. Верхний спейсер
        const topSpacer = document.createElement('tr');
        topSpacer.style.height = `${topSpacerHeight}px`;
        const topSpacerCell = document.createElement('td');
        topSpacerCell.colSpan = visibleColumnsCount;
        topSpacerCell.style.padding = '0';
        topSpacerCell.style.border = '0';
        topSpacer.appendChild(topSpacerCell);
        fragment.appendChild(topSpacer);

        // 2. Собираем карту существующих DOM-строк (только видимых в данный момент)
        const existingRowsMap = new Map();
        Array.from(tableBody.children).forEach((row) => {
          if (row.dataset && row.dataset.assetSymbol) {
            // Убедимся, что это строка с данными, а не спейсер
            existingRowsMap.set(row.dataset.assetSymbol, row);
          }
        });

        const rowsToKeepOrUpdate = new Set();

        // 3. Обрабатываем видимые строки
        for (let i = startIndex; i < endIndex; i++) {
          const asset = sortedFilteredAssets[i];
          const rowId = `asset-row-${asset.symbol}`;
          // HTML для <td>...</td>
          const cellsContentHtml = generateCellsHtml(asset);

          let rowNode = existingRowsMap.get(asset.symbol);

          if (rowNode) {
            // Строка существует
            // Сравнение: если HTML ячеек изменился, обновляем.
            // Это все еще грубое сравнение. Идеально - сравнивать каждое поле данных.
            if (rowNode.innerHTML !== cellsContentHtml) {
              rowNode.innerHTML = cellsContentHtml;
            }
            // Помечаем, что эту строку нужно оставить
            rowsToKeepOrUpdate.add(asset.symbol);
          } else {
            // Новая строка
            rowNode = document.createElement('tr');
            rowNode.id = rowId;
            rowNode.dataset.assetId = asset.id;
            rowNode.dataset.assetSymbol = asset.symbol;
            rowNode.tabIndex = 0;
            rowNode.setAttribute(
              'aria-label',
              `${asset.name} - ${formatPrice(asset.price?.current)} USD`
            );
            rowNode.innerHTML = cellsContentHtml;
          }
          // Добавляем в фрагмент (новую или существующую)
          fragment.appendChild(rowNode);
        }

        // 4. Нижний спейсер
        const bottomSpacer = document.createElement('tr');
        bottomSpacer.style.height = `${bottomSpacerHeight}px`;
        const bottomSpacerCell = document.createElement('td');
        bottomSpacerCell.colSpan = visibleColumnsCount;
        bottomSpacerCell.style.padding = '0';
        bottomSpacerCell.style.border = '0';
        bottomSpacer.appendChild(bottomSpacerCell);
        fragment.appendChild(bottomSpacer);

        // Полностью заменяем содержимое tbody один раз
        tableBody.innerHTML = '';
        tableBody.appendChild(fragment);
      }
      // #endregion

      // -----------------------------------------------------------------------
      // ГРАФИКИ
      // -----------------------------------------------------------------------
      // #region

      /**
      * Подготавливает панель графика и инициирует загрузку данных для графика.
      * Эта функция вызывается ПОСЛЕ того, как drawer.js уже открыл панель (или одновременно).
      * @param {HTMLElement} chartButton - Кнопка, по которой кликнули.
      */
      async function prepareAndFetchChartData(chartButton) {
        const { assetSymbol } = chartButton.dataset;

        currentChartTicker = assetSymbol;

        // Находим полный объект данных для этого актива из allAssets
        // Это важно, так как нам нужны данные price.today, price.yesterday и т.д.
        const assetData = allAssets.find((a) => a.symbol === assetSymbol);

        if (!assetData) {
          if (IS_DEVELOPMENT) {
            console.error(
              `[Chart] Asset data for symbol ${assetSymbol} not found in allAssets.`
            );
          }

          // Ошибка в панели графика
          if (assetChartContainer) {
            assetChartContainer.innerHTML =
              '<p class="text-center">{{ "Asset data not found."|trans|escape("js") }}</p>';
          }

          // Прочерки вместо ненайденных значений
          const fallbackFields = [
            drawerChartSymbol,
            drawerChartPrice,
            drawerChartPriceChange,
            drawerChartOpen,
            drawerChartHigh,
            drawerChartLow,
          ];

          fallbackFields.forEach((element) => {
            const targetElement = element;
            if (targetElement) targetElement.textContent = '---';
          });

          return;
        }

        const assetName = assetData.name || assetSymbol;

        if (drawerChart) {
          // 1. Иконка и фоллбэк
          if (drawerChartIcon && drawerChartIconFallback) {
            if (assetData.icon) {
              drawerChartIcon.src = assetData.icon;
              drawerChartIcon.alt = assetName;
              // Показать img
              drawerChartIcon.style.display = '';
              // Скрыть фоллбэк
              drawerChartIconFallback.style.display = 'none';
              // Обработчик ошибок для img, если иконка не загрузится
              drawerChartIcon.onerror = () => {
                drawerChartIcon.style.display = 'none';
                drawerChartIconFallback.textContent = assetSymbol
                  .substring(0, 3)
                  .toUpperCase();
                drawerChartIconFallback.style.display = 'inline-flex';
                // Убрать обработчик, чтобы не было зацикливания
                drawerChartIcon.onerror = null;
              };
            } else {
              // Скрыть img
              drawerChartIcon.style.display = 'none';
              drawerChartIconFallback.textContent = assetSymbol
                .substring(0, 3)
                .toUpperCase();
              // Показать фоллбэк
              drawerChartIconFallback.style.display = 'inline-flex';
            }
          }

          // 2. Название актива (для двух HTML-элементов)
          if (drawerChartTitleElements) {
            drawerChartTitleElements.forEach((element) => {
              const titleElement = element;
              titleElement.textContent = assetName;
            });
          }

          // 3. Символ (например, BTC-USD)
          if (drawerChartSymbol) {
            drawerChartSymbol.textContent = `${assetSymbol}-USD`;
          }

          // 4. Текущая цена и изменение за 24ч
          if (drawerChartPrice) {
            // Обновляем текстовый узел цены
            drawerChartPrice.childNodes[0].nodeValue = `${formatPrice(assetData.price?.current)} `;
          }
          if (drawerChartPriceChange && assetData.price) {
            const change24hValue = calculateChange24hValue(assetData.price);
            if (change24hValue !== null && !Number.isNaN(change24hValue)) {
              const formattedChange = `${change24hValue > 0 ? '+' : ''}${change24hValue.toFixed(2)}%`;
              drawerChartPriceChange.textContent = formattedChange;
              drawerChartPriceChange.classList.toggle(
                'is-positive',
                change24hValue > 0
              );
              drawerChartPriceChange.classList.toggle(
                'is-negative',
                change24hValue < 0
              );
              drawerChartPriceChange.style.display = '';
            } else {
              drawerChartPriceChange.textContent = '–';
              // Сброс классов
              drawerChartPriceChange.className = 'e-asset-details__price-change';
              // или показать прочерк
              drawerChartPriceChange.style.display = 'none';
            }
          }

          // 5. Статистика H, L (сегодняшние) - их мы можем взять из assetData.price.today
          const todayPrice = assetData.price?.today;
          if (drawerChartHigh) {
            drawerChartHigh.textContent =
              todayPrice?.max !== undefined ? formatPrice(todayPrice.max) : '–';
          }
          if (drawerChartLow) {
            drawerChartLow.textContent =
              todayPrice?.min !== undefined ? formatPrice(todayPrice.min) : '–';
          }
          // Для Open пока ставим заглушку или очищаем, т.к. он будет из свечей
          if (drawerChartOpen) {
            drawerChartOpen.textContent = '...';
          }
        }

        if (assetChartContainer) {
          assetChartContainer.innerHTML =
            '<p class="is-loading-state p-m text-center">{{ "Loading chart data..."|trans|escape("js") }}</p>';
        }

        if (IS_DEVELOPMENT) {
          console.log(
            `[Chart] Запрос данных для графика: ID=${assetSymbol}, Symbol=${assetSymbol}`
          );
        }

        const initialPeriodRadio = periodRadioButtons.find((r) => r.checked);
        if (initialPeriodRadio) currentChartPeriod = initialPeriodRadio.value;

        const chartCandleData = await fetchChartData(assetSymbol);

        if (drawerChartOpen && chartCandleData && chartCandleData.length > 0) {
          // Пока предположим, что chartCandleData[0] - это открытие для запрошенного периода.
          // TODO: уточнить этот момент.
          // Если period='1d' означает данные за последние 24 часа, то chartCandleData[0] - это самая старая свеча из этих 24ч.

          // Простой вариант: берем 'o' из первой доступной свечи
          const firstCandleOpenPrice = chartCandleData[0]?.o;
          drawerChartOpen.textContent =
            firstCandleOpenPrice !== undefined
              ? formatPrice(firstCandleOpenPrice)
              : '–';
        } else if (drawerChartOpen) {
          // Если данных свечей нет или ошибка, ставим прочерк для Open
          drawerChartOpen.textContent = '–';
        }

        if (assetChartContainer) {
          if (chartCandleData && chartCandleData.length > 0) {
            renderCandlestickChart(chartCandleData, assetChartContainer);
          } else if (chartCandleData && chartCandleData.length === 0) {
            assetChartContainer.innerHTML =
              '<p class="p-m text-center">{{ "No chart data available for the selected period."|trans|escape("js") }}</p>';
            if (chartInstance) {
              chartInstance.destroy();
              chartInstance = null;
            }
          } else {
            assetChartContainer.innerHTML =
              '<p class="p-m text-center">{{ "Unable to load chart data. Please go to the ‘Contact Us’ section and report the issue to support."|trans|escape("js") }}</p>';
            if (chartInstance) {
              chartInstance.destroy();
              chartInstance = null;
            }
          }
        }
      }

      /**
      * Определяет смещение часового пояса относительно UTC
      * @returns {number} Смещение в часах (например, 3 для UTC+3, -5 для UTC-5)
      */
      function getTimezoneOffset() {
        // e.g., -180 for UTC+3 (в минутах)
        const offset = new Date().getTimezoneOffset();
        return (offset / 60) * -1;
      }

      /**
      * Fetches chart data for a given asset.
      * @param {string} ticker - The asset ticker (e.g., "BTC").
      * @param {string} period - The period for the chart data (e.g., "1d", "1M").
      * @param {string} timeframe - The timeframe for the chart (e.g., "1h", "4h").
      * @returns {Promise<Array|null>} A promise that resolves to an array of chart data points or null on error.
      */
      async function fetchChartData(ticker, period = '1d', timeframe = '1m') {
        if (!ticker) {
          if (IS_DEVELOPMENT) {
            console.error('[Chart] Ticker is required to fetch chart data.');
          }
          return null;
        }

        let chartCandleData = null;
        const timezoneoffset = getTimezoneOffset();

        if (IS_DEVELOPMENT) {
          const devFixtureUrl = `${ASSETS_PATH_PREFIX}/assets/data/fixtures/crypto-data-candles.json`;
          try {
            const response = await fetch(devFixtureUrl);
            if (!response.ok) {
              throw new Error(
                `Failed to load dev chart data fixture (${devFixtureUrl}), status: ${response.status}`
              );
            }
            const responseData = await response.json();
            if (
              Array.isArray(responseData) &&
              responseData.length === 2 &&
              Array.isArray(responseData[0]) &&
              responseData[0][0] === 'OK' &&
              Array.isArray(responseData[1])
            ) {
              // eslint-disable-next-line prefer-destructuring
              chartCandleData = responseData[1];
            } else {
              console.warn(
                `[Chart] Dev chart data fixture (${devFixtureUrl}) has unexpected format for ticker ${ticker}. Expected [["OK"], [candlesArray]]. Received:`,
                responseData
              );
              chartCandleData = [];
            }
          } catch (error) {
            console.error(
              '[Chart] Error fetching or parsing dev chart data fixture:',
              error
            );
            chartCandleData = null;
          }
        } else {
          // Production
          const currentLang = window.location.pathname
            .split('/')[1]
            ?.match(/^[a-z]{2}$/)
            ? window.location.pathname.split('/')[1]
            : '';
          const fullProdApiUrl = `${window.location.origin}/${currentLang ? `${currentLang}/` : ''}json/pricechart`;

          // Формируем тело запроса как URLSearchParams
          const chartParams = new URLSearchParams();
          chartParams.append('ticker', ticker);
          chartParams.append('period', period);
          chartParams.append('timeframe', timeframe);
          chartParams.append('timezoneoffset', timezoneoffset.toString());
          chartParams.append('jsonfather', 'true');

          try {
            const response = await fetch(fullProdApiUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
              },
              credentials: 'include',
              body: chartParams.toString(),
            });

            if (!response.ok) {
              let errorDetail = `Request failed with status: ${response.status}`;
              try {
                const errorJson = await response.json();
                if (Array.isArray(errorJson) && errorJson.length > 0) {
                  errorDetail = errorJson[1] || JSON.stringify(errorJson);
                } else {
                  errorDetail = JSON.stringify(errorJson);
                }
              } catch (e) {
                /* не удалось распарсить JSON ошибки */
              }
              throw new Error(errorDetail);
            }

            const responseData = await response.json();
            if (
              Array.isArray(responseData) &&
              responseData.length === 2 &&
              responseData[0] === 'OK' &&
              Array.isArray(responseData[1])
            ) {
              [, chartCandleData] = responseData;
            } else {
              console.error(
                '[Chart] Unexpected API response format for chart data:',
                responseData
              );
              throw new Error('Invalid chart data format from server.');
            }
          } catch (error) {
            console.error(
              `[Chart] Error fetching prod chart data for ${ticker}:`,
              error.message
            );
            chartCandleData = null;
          }
        }
        return chartCandleData;
      }

      // Переменная для хранения экземпляра графика, чтобы его можно было обновлять/уничтожать
      let chartInstance = null;

      /**
      * Renders a candlestick chart in the given container.
      * @param {Array} candleData - Array of candlestick data points ({x, o, h, l, c}).
      * @param {HTMLElement} containerElement - The HTML element to render the chart in.
      */
      function renderCandlestickChart(candleData, containerElement) {
        if (!containerElement) {
          if (IS_DEVELOPMENT) {
            console.error(
              '[Chart] Container element not found for rendering chart.'
            );
          }
          return;
        }

        if (chartInstance) {
          chartInstance.destroy();
          chartInstance = null;
        }

        const wrapper = document.createElement('div');
        const canvas = document.createElement('canvas');
        wrapper.appendChild(canvas);
        // Очищает контейнер и добавляет новый canvas
        containerElement.replaceChildren(wrapper);
        const ctx = canvas.getContext('2d');

        if (!candleData || candleData.length === 0) {
          const messageElement = document.createElement('p');
          messageElement.className = 'p-m text-center';
          messageElement.textContent =
            '{{ "No data to display chart."|trans|escape("js") }}';
          containerElement.replaceChildren(messageElement);
          return;
        }

        const processedData = candleData.map((d) => {
          let xValue;

          if (typeof xValue === 'undefined') {
            const dateString = d.x;

            const parsedDate = new Date(dateString);
            // Получаем timestamp
            xValue = parsedDate.getTime();
          }

          return {
            // Теперь xValue всегда будет определен
            x: xValue,
            o: Number(d.o),
            h: Number(d.h),
            l: Number(d.l),
            c: Number(d.c),
          };
        });

        const DURATION = 240;
        const colorUp = 'var(--color-ink-text-success)';
        const colorDown = 'var(--color-ink-2ry-error)';
        const colorUnchanged = 'var(--color-ink-3ry-error)';

        // eslint-disable-next-line no-undef
        chartInstance = new Chart(ctx, {
          type: 'candlestick',
          data: {
            datasets: [
              {
                barThickness: 7,
                color: {
                  up: colorUp,
                  down: colorDown,
                  unchanged: colorUnchanged,
                },
                borderColor: 'inherit',
                data: processedData,
              },
            ],
          },
          options: {
            animation: {
              duration: DURATION,
            },
            maintainAspectRatio: false,
            onResize: (chart, size) => {
              const dataset = chart.config.data.datasets[0];
              const allData = dataset.data;

              if (!allData || allData.length === 0) {
                /* eslint-disable no-param-reassign */
                chart.options.scales.x.min = undefined;
                chart.options.scales.x.max = undefined;
                return;
              }

              const barThickness = dataset.barThickness || 7;
              // Желаемый пробел в пикселях
              const desiredSpaceBetweenCandles = 2;
              const candleCellWidth = barThickness + desiredSpaceBetweenCandles;

              let maxVisibleCandles = Math.floor(size.width / candleCellWidth);
              maxVisibleCandles = Math.max(
                1,
                Math.min(maxVisibleCandles, allData.length)
              );

              let newXMin;
              let newXMax;

              if (allData.length <= maxVisibleCandles) {
                newXMin = allData[0].x;
                newXMax = allData[allData.length - 1].x;
              } else {
                newXMin = allData[allData.length - maxVisibleCandles].x;
                newXMax = allData[allData.length - 1].x;
              }

              const currentXMin = chart.options.scales.x.min;
              const currentXMax = chart.options.scales.x.max;
              const newXMinTime = newXMin ? new Date(newXMin).getTime() : undefined;
              const newXMaxTime = newXMax ? new Date(newXMax).getTime() : undefined;
              const currentXMinTime = currentXMin
                ? new Date(currentXMin).getTime()
                : undefined;
              const currentXMaxTime = currentXMax
                ? new Date(currentXMax).getTime()
                : undefined;

              if (
                newXMinTime !== currentXMinTime ||
                newXMaxTime !== currentXMaxTime
              ) {
                chart.options.scales.x.min = newXMin;
                chart.options.scales.x.max = newXMax;
                /* eslint-enable no-param-reassign */
                chart.update('none');
              }
            },
            plugins: {
              legend: {
                display: false,
              },
              tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'var(--color-bg-level-02)',
                titleColor: 'rgb(255 255 255 / 0.6)',
                titleFont: { weight: 'normal' },
                bodyColor: 'rgb(255 255 255 / 0.87)',
                bodyFont: { weight: 'bold' },
                borderWidth: 0,
                padding: 16,
                displayColors: false,
                callbacks: {
                  label(context) {
                    const datapoint = context.raw;
                    if (datapoint !== null && typeof datapoint === 'object') {
                      return [
                        `O: ${formatPrice(datapoint.o)}`,
                        `H: ${formatPrice(datapoint.h)}`,
                        `L: ${formatPrice(datapoint.l)}`,
                        `C: ${formatPrice(datapoint.c)}`,
                      ];
                    }
                    return context.dataset.label || '';
                  },
                },
              },
            },
            responsive: true,
            scales: {
              x: {
                type: 'time',
                distribution: 'series',
                grid: {
                  color: 'rgb(255 255 255 / 0.08)',
                  drawTicks: false,
                },
                offset: true,
                ticks: {
                  autoSkip: true,
                  autoSkipPadding: 15,
                  color: 'rgb(255 255 255 / 0.6)',
                  maxRotation: 0,
                  padding: 12,
                  source: 'auto',
                },
                time: {
                  displayFormats: {
                    millisecond: 'HH:mm:ss.SSS',
                    second: 'HH:mm:ss',
                    minute: 'HH:mm',
                    hour: 'HH:mm',
                    day: 'MMM d',
                    week: 'MMM d, yyyy',
                    month: 'MMM yyyy',
                    quarter: 'QQQ yyyy',
                    year: 'yyyy',
                  },
                  tooltipFormat: 'yyyy-MM-dd HH:mm',
                },
              },
              y: {
                beginAtZero: false,
                border: {
                  display: true,
                  color: 'rgb(255 255 255 / 0.08)',
                  width: 1,
                },
                grid: {
                  color: 'rgb(255 255 255 / 0.08)',
                },
                position: 'right',
                ticks: {
                  color: 'rgb(255 255 255 / 0.6)',
                  padding: 12,
                },
              },
            },
          },
        });
      }

      /**
      * Обновляет доступность (enabled/disabled) и состояние checked для таймфреймов
      * в зависимости от выбранного периода.
      * @param {string} selectedPeriod - Выбранное значение периода (e.g., '1d', '1M').
      */
      function updateTimeframeOptions(selectedPeriodValue) {
        const validTimeframes =
          VALID_TIMEFRAMES_FOR_PERIOD[selectedPeriodValue] || [];
        let newActiveTimeframeValue = null;

        // 1. Определяем, какой таймфрейм должен быть активным
        if (validTimeframes.includes(currentChartTimeframe)) {
          newActiveTimeframeValue = currentChartTimeframe;
        } else if (validTimeframes.length > 0) {
          [newActiveTimeframeValue] = validTimeframes;
        }

        // Обновляем глобальную переменную
        currentChartTimeframe = newActiveTimeframeValue;

        // 2. Обновляем состояние радиокнопок
        timeframeRadioButtons.forEach((radio) => {
          const timeframeValue = radio.value;
          const labelAction = radio.closest('.e-menu__action');

          if (validTimeframes.includes(timeframeValue)) {
            // РАЗБЛОКИРОВАТЬ
            radio.removeAttribute('disabled');
            if (labelAction) labelAction.classList.remove('is-disabled');
            radio.setAttribute(
              'checked',
              timeframeValue === currentChartTimeframe ? '' : null
            );
          } else {
            // ЗАБЛОКИРОВАТЬ
            radio.setAttribute('disabled', 'disabled');
            if (labelAction) labelAction.classList.add('is-disabled');
            radio.removeAttribute('checked');
          }
        });

        // 3. Обновляем текст в <summary> для меню таймфрейма
        if (drawerChartTimeframeMenu) {
          const summary = drawerChartTimeframeMenu.querySelector('summary');
          const activeRadio = timeframeRadioButtons.find((r) => r.checked);
          if (summary && activeRadio) {
            summary.childNodes[0].nodeValue = `${activeRadio.dataset.shortcut || activeRadio.value} `;
          } else if (summary) {
            summary.childNodes[0].nodeValue = '--- ';
          }
        }

        if (IS_DEVELOPMENT)
          console.log(
            `[Chart] Timeframe options updated for period "${selectedPeriodValue}". New current timeframe: "${currentChartTimeframe}"`
          );
      }

      /**
      * Запрашивает и отображает данные графика на основе текущих ticker, period, timeframe.
      */
      async function refreshChartData() {
        if (IS_DEVELOPMENT) {
          console.log(
            `[Chart Debug] refreshChartData CALLED. Ticker: ${currentChartTicker}, Period: ${currentChartPeriod}, Timeframe: ${currentChartTimeframe}`
          );
        }

        if (!currentChartTicker) {
          if (IS_DEVELOPMENT)
            console.warn('[Chart] Ticker not set, cannot refresh chart.');
          return;
        }

        if (assetChartContainer) {
          assetChartContainer.innerHTML =
            '<p class="is-loading-state p-m text-center">{{ "Loading chart data..."|trans|escape("js") }}</p>';
        }

        // Сбрасываем цену открытия
        if (drawerChartOpen) drawerChartOpen.textContent = '...';

        // Этот console.log ДОЛЖЕН БЫТЬ ЗДЕСЬ, чтобы показать, что мы готовимся к fetch
        if (IS_DEVELOPMENT) {
          console.log(
            `[Chart] ЗАПРОС ДАННЫХ (из refreshChartData): Ticker=${currentChartTicker}, Period=${currentChartPeriod}, Timeframe=${currentChartTimeframe}`
          );
        }

        const chartCandleData = await fetchChartData(
          currentChartTicker,
          currentChartPeriod,
          currentChartTimeframe
        );

        // Обновляем цену открытия в заголовке, если она там есть и данные пришли
        if (drawerChartOpen && chartCandleData && chartCandleData.length > 0) {
          const firstCandleOpenPrice = chartCandleData[0]?.o;
          drawerChartOpen.textContent =
            firstCandleOpenPrice !== undefined
              ? formatPrice(firstCandleOpenPrice)
              : '–';
        } else if (drawerChartOpen) {
          drawerChartOpen.textContent = '–';
        }

        if (assetChartContainer) {
          if (chartCandleData && chartCandleData.length > 0) {
            renderCandlestickChart(chartCandleData, assetChartContainer);
          } else if (chartCandleData && chartCandleData.length === 0) {
            assetChartContainer.innerHTML =
              '<p class="p-m text-center">{{ "No chart data available for the selected period."|trans|escape("js") }}</p>';
            if (chartInstance) {
              chartInstance.destroy();
              chartInstance = null;
            }
          } else {
            assetChartContainer.innerHTML =
              '<p class="p-m text-center">{{ "Could not load chart data."|trans|escape("js") }}</p>';
            if (chartInstance) {
              chartInstance.destroy();
              chartInstance = null;
            }
          }
        }
      }

      function handlePeriodChange(event) {
        const selectedPeriod = event.target.value;
        const selectedShortcut = event.target.dataset.shortcut || selectedPeriod;

        if (currentChartPeriod !== selectedPeriod) {
          currentChartPeriod = selectedPeriod;
          if (IS_DEVELOPMENT)
            console.log(`[Chart] Period changed to: ${currentChartPeriod}`);

          // Обновляем текст в <summary> для периода
          if (drawerChartPeriodMenu) {
            const summary = drawerChartPeriodMenu.querySelector('summary');
            // Пробел для отступа от chevron
            if (summary) summary.childNodes[0].nodeValue = `${selectedShortcut} `;
          }

          // Обновляем доступные таймфреймы и currentChartTimeframe обновится внутри, если нужно
          updateTimeframeOptions(currentChartPeriod);
          // Запрашиваем новые данные для графика
          refreshChartData();
        }
        // Закрываем popover периода
        if (drawerChartPeriodMenu && drawerChartPeriodMenu.hasAttribute('open')) {
          drawerChartPeriodMenu.removeAttribute('open');
        }
      }

      function handleTimeframeChange(event) {
        if (IS_DEVELOPMENT) {
          console.log(
            '[Chart Debug] handleTimeframeChange CALLED. Target value:',
            event.target.value
          );
        }
        const selectedTimeframe = event.target.value;
        const selectedShortcut = event.target.dataset.shortcut || selectedTimeframe;

        if (currentChartTimeframe !== selectedTimeframe) {
          currentChartTimeframe = selectedTimeframe;
          if (IS_DEVELOPMENT)
            console.log(`[Chart] Timeframe changed to: ${currentChartTimeframe}`);

          // Обновляем текст в <summary> для таймфрейма
          if (drawerChartTimeframeMenu) {
            const summary = drawerChartTimeframeMenu.querySelector('summary');
            if (summary) summary.childNodes[0].nodeValue = `${selectedShortcut} `;
          }
          // Запрашиваем новые данные для графика
          refreshChartData();
        }
        // Закрываем popover таймфрейма
        if (
          drawerChartTimeframeMenu &&
          drawerChartTimeframeMenu.hasAttribute('open')
        ) {
          drawerChartTimeframeMenu.removeAttribute('open');
        }
      }

      // #endregion

      // -----------------------------------------------------------------------
      // УТИЛИТЫ
      // -----------------------------------------------------------------------
      // #region

      const throttle = (func, limit) => {
        let lastFunc;
        let lastRan;

        return function throttled(...args) {
          const context = this;

          if (!lastRan) {
            func.apply(context, args);
            lastRan = Date.now();
            return;
          }

          clearTimeout(lastFunc);
          lastFunc = setTimeout(
            () => {
              if (Date.now() - lastRan >= limit) {
                func.apply(context, args);
                lastRan = Date.now();
              }
            },
            limit - (Date.now() - lastRan)
          );
        };
      };

      function announceUpdate(message) {
        if (screenReaderAnnouncer) {
          screenReaderAnnouncer.textContent = message;
        }
      }

      // Add window unload handler for cleanup
      window.addEventListener('unload', cleanup);
      // #endregion

      // -----------------------------------------------------------------------
      // ИНИЦИАЛИЗАЦИЯ
      // -----------------------------------------------------------------------
      // #region
      const init = () => {
        try {
          if (!table || !scrollContainer || !tableBody || !tableHead) {
            throw new Error('Required DOM elements not found');
          }

          if (!tableBody || !drawerChart || !assetChartContainer) {
            if (IS_DEVELOPMENT) {
              console.error(
                'One or more critical elements for chart functionality are missing.'
              );
              // Можно либо остановить инициализацию части функционала, либо показать ошибку
            }
          }

          // Начальная установка доступности таймфреймов и текущих значений
          const initialCheckedPeriod = periodRadioButtons.find((r) => r.checked);
          if (initialCheckedPeriod) {
            currentChartPeriod = initialCheckedPeriod.value;
            // Это установит и currentChartTimeframe, если нужно
            updateTimeframeOptions(currentChartPeriod);
          } else if (periodRadioButtons.length > 0) {
            // Если ничего не выбрано, выбираем первое
            periodRadioButtons[0].checked = true;
            currentChartPeriod = periodRadioButtons[0].value;
            updateTimeframeOptions(currentChartPeriod);
          }

          // Убедимся, что currentChartTimeframe установлен из (возможно обновленного) DOM
          const initialCheckedTimeframe = timeframeRadioButtons.find(
            (r) => r.checked
          );
          if (initialCheckedTimeframe) {
            currentChartTimeframe = initialCheckedTimeframe.value;
          } else if (timeframeRadioButtons.find((r) => !r.disabled)) {
            // Если ничего не выбрано, но есть доступные
            const firstEnabledTF = timeframeRadioButtons.find((r) => !r.disabled);
            if (firstEnabledTF) {
              firstEnabledTF.checked = true;
              currentChartTimeframe = firstEnabledTF.value;
            }
          }

          // Привязываем обработчики к радиокнопкам
          periodRadioButtons.forEach((radio) => {
            radio.addEventListener('change', handlePeriodChange);
          });
          timeframeRadioButtons.forEach((radio) => {
            radio.addEventListener('change', handleTimeframeChange);
          });

          // Заполнить чекбоксы колонок
          populateColumnCheckboxes();

          // Сгенерировать заголовки таблицы на основе видимых колонок
          generateTableHeadHtml();

          // sortButtons назначаются в generateTableHeadHtml, обработчики там же

          // Обновляем обработчик скролла, чтобы он вызывал patchTableBody
          // Используем patchTableBody
          const throttledPatch = throttle(patchTableBody, 100);
          // Привязываем throttledPatch
          scrollContainer.addEventListener('scroll', throttledPatch);

          // fetchData вызовет processData -> applySortAndFilter -> patchTableBody
          fetchData();
          updateIntervalId = setInterval(fetchData, REFRESH_INTERVAL_MS);

          // Инициализировать счетчик фильтров
          updateFilterCountBadge();

          announceUpdate('{{ "Table loading."|trans|escape("js") }}');

          // Делегированный обработчик для кнопок графика (реагирует на те же кнопки, что и drawer.js)
          // Он сработает после/одновременно с drawer.js
          tableBody.addEventListener('click', (event) => {
            const chartButton = event.target.closest(
              '[data-role="drawer-toggle"][data-target="drawer-chart"]'
            );
            if (chartButton) {
              // Кнопка открытия графика была нажата.
              // drawer.js уже должен был начать открывать панель.
              // Мы здесь готовим контент для панели.
              prepareAndFetchChartData(chartButton);
            }
          });
        } catch (error) {
          if (IS_DEVELOPMENT) {
            console.error('Initialization failed:', error);
          }
          displayErrorState(
            '{{ "We couldn’t show the table. Something went wrong during setup."|trans|escape("js") }}'
          );
        }
      };

      document.addEventListener('DOMContentLoaded', init);
      // #endregion
    })();

  </script>
{% endblock %}
