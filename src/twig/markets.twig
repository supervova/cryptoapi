{# markets.twig.html #}
{% extends "partials/base.twig" %}

{% block config %}
  {{ parent() }}

  {% if ENV == 'development' %}
    {% set page = page|merge(
      {
        app: true,
        classes: 'is-markets',
        styles: 'markets.css',
      }
    ) %}
    {% set user = user|merge({id: 1}) %}

    {# Начальное поле сортировки #}
    {% set initial_sort_field = 'rating' %}

    {# Начальное направление #}
    {% set initial_sort_direction = 'asc' %}

    {% set api_url = '/assets/data/fixtures/crypto-data.json' %}
  {% else %}
    {% set api_url = 'https://cryptoapi.ai/json/trindxrating' %}
  {% endif %}

  {# Определяем колонки здесь, чтобы можно было управлять ими из Twig, если понадобится.
  JS будет использовать этот же набор по умолчанию, но сможет его переопределить.
  Первая и последняя колонки скрыты, пока не готов функционал: `visible: false` #}

  {% set default_columns = [
    {key: 'watchlist', type: 'action', label: 'Watchlist', sortable: false, visible: false},
    {key: 'asset', type: 'text', label: 'Asset', sortable: true},
    {key: 'price', type: 'num', label: 'Price, $', sortable: true},
    {key: 'change_24h', type: 'num', label: 'Chg (24H), %', sortable: true},
    {key: 'rating', type: 'num', label: 'Rating', sortable: true},
    {key: 'risk', type: 'icon', label: 'Risk', sortable: false},
    {key: 'trindex', type: 'num', label: 'TRIndex', sortable: true},
    {key: 'rsi', type: 'num', label: 'RSI (7D)', sortable: true},
    {key: 'chart', type: 'action', label: 'Chart', sortable: false, visible: false}
  ] %}

{% endblock %}

{# {% block head %}
{% endblock %} #}

{% block search %}
  <form class="e-header__search" role="search">
    <label class="visually-hidden" for="header-search">{{ 'Search coins by name or symbol…'|trans }}</label>
    {% include 'partials/icon.twig' with {name: 'search'} %}
    <input type="search" id="header-search" placeholder="{{ 'Search coins by name or symbol…'|trans }}">
  </form>
{% endblock %}

{% block content %}
{% set visible_columns_count = 0 %}
{% for col_def in default_columns %}
  {% if col_def.visible is not defined or col_def.visible is not same as(false) %}
    {% set visible_columns_count = visible_columns_count + 1 %}
  {% endif %}
{% endfor %}

<div class="e-container">

  <header class="e-main__header">
    <h1>{{ 'Markets'|trans }}. <span class="text-2ry">{{ 'Asset Ranking'|trans }}</span></h1>
    {# Фильтры пока не реализованы, но кнопка остается как плейсхолдер #}
    <div role="status" aria-live="polite">
      <button class="e-btn is-tag has-start-icon" type="button" data-role="drawer-toggle" data-target="drawer-filter">
        {% include 'partials/icon.twig' with {name: 'filter'} %}
        {{ 'Filters'|trans }} 0
      </button>
    </div>
  </header>

  <div class="e-scroller is-2-directions" id="virtual-scroll-container">
    <table
      class="table has-hovered-rows has-2-liners"
      id="crypto-table" data-sort-field="{{ initial_sort_field }}"
      data-sort-direction="{{ initial_sort_direction }}"
      aria-live="polite"
      aria-busy="true"
    >
      <caption class="visually-hidden">{{ 'Cryptocurrency Market Data Table'|trans }}</caption>
      <thead>
        <tr>
          {# Генерируем заголовки на основе конфигурации колонок #}
          {% for col in default_columns %}
            {% if col.visible is not defined or col.visible is not same as(false) %}
              {% set label = col.label|trans %}
              <th class="table__cell is-{{ col.type }}{{ col.key == 'watchlist' or col.key == 'chart' ? ' is-action' : '' }}" scope="col" {% if col.type == 'action' or col.type == 'icon' %} aria-label="{{ label }}" {% endif %}>
                {% if col.sortable %}
                  <button
                    class="e-btn is-sort {{ initial_sort_field == col.key ? 'is-active' : '' }} {{ initial_sort_field == col.key and initial_sort_direction == 'desc' ? 'is-desc' : '' }}"
                    type="button"
                    data-sort-field="{{ col.key }}"
                    aria-label="{{ 'Sort by this column'|trans }}" {# Это общая фраза, переводится нормально #}
                    aria-sort="{{ initial_sort_field == col.key ? (initial_sort_direction == 'asc' ? 'ascending' : 'descending') : 'none' }}"
                  >
                    {{ label }}
                    {% include 'partials/icon.twig' with {name: 'up'} %}
                  </button>
                {% else %}
                  {# Не сортируемая колонка #}
                  {{ label }}
                {% endif %}
              </th>
            {% endif %}
          {% endfor %}
        </tr>
      </thead>

      <tbody id="crypto-table-body">
        {# Начальное состояние - Загрузка #}
        <tr id="loading-row">
          <td class="table__cell is-loading-state" colspan="{{ visible_columns_count }}"> {# Теперь visible_columns_count должен быть доступен и равен 7 #}
            <p>{{ 'Loading data...'|trans }}</p>
          </td>
        </tr>
        {# Сюда JS будет вставлять строки или сообщение "Нет данных" #}
      </tbody>
    </table>
  </div>

  <!-- Скрытое уведомление для Screen Readers -->
  <div class="visually-hidden" aria-live="polite" id="screen-reader-announcement"></div>

</div>
{% endblock %}

{% block body_suffix %}
  {# Выдвижная панель графика #}
  <dialog class="e-drawer is-bottom" id="drawer-chart">
    <div class="e-drawer__header">
      <h2>{{ 'Asset Chart'|trans }}</h2>
      <button class="e-btn is-close" type="button" data-role="close-drawer" aria-label="{{ 'Close'|trans }}">
        {% include 'partials/icon.twig' with {name: 'sm-x-mark', classes: 'is-sm', assets_prefix: assets_prefix} %}
      </button>
    </div>
    <div class="e-drawer__content">
      <div class="e-drawer__chart" id="asset-chart"></div>
    </div>
  </dialog>

  <dialog class="e-drawer is-end" id="drawer-filter">
    <div class="e-drawer__header">
      <h2 class="e-h3">{{ 'Filters'|trans }}</h2>
    </div>

    <div class="e-drawer__content">
      <form class="e-form" id="filters-form">
        {# Диапазон цены #}
        <fieldset>
          <legend class="e-label mb-xs">{{ 'Price'|trans }}:</legend>
          <div class="e-form__row phone:2-columns">
            <div>
              <label class="e-label visually-hidden" for="filter-price-min">{{ 'From'|trans }}</label>
              <input id="filter-price-min" name="filter-price-min" type="number" step="any" min="0" placeholder="{{ 'From'|trans }}">
            </div>
            <div>
              <label class="e-label visually-hidden" for="filter-price-max">{{ 'To'|trans }}</label>
              <input id="filter-price-max" name="filter-price-max" type="number" step="any" min="0" placeholder="{{ 'To'|trans }}">
            </div>
          </div>
        </fieldset>

        {# RSI (7 дней) #}
        <fieldset>
          <legend class="e-label mb-xs">{{ 'RSI (7D)'|trans }}:</legend>
          <div class="e-form__row phone:2-columns">
            <div>
              <label class="e-label visually-hidden" for="filter-rsi-min">RSI {{ 'From'|trans }}</label>
              <input id="filter-rsi-min" name="filter-rsi-min" type="number" min="0" max="100" placeholder="{{ 'From'|trans }}">
            </div>
            <div>
              <label class="e-label visually-hidden" for="filter-rsi-max">RSI {{ 'To'|trans }}</label>
              <input id="filter-rsi-max" name="filter-rsi-max" type="number" min="0" max="100" placeholder="{{ 'To'|trans }}">
            </div>
          </div>
        </fieldset>

        {# Рейтинг #}
        <div class="mb-2">
          <label class="e-label" for="filter-rating-max">{{ 'Rating (lower is better):'|trans }}</label> {# Изменено для ясности "до X" #}
          <input class="w-full" id="filter-rating-max" name="filter-rating-max" type="number" min="1" placeholder="{{ 'E.g.,'|trans }} 50">
          {# Убрал ошибку, т.к. валидация будет в JS или на сервере #}
        </div>

        {# Риск #}
        <div class="mb-2">
          <label class="e-label" for="filter-risk">{{ 'Risk Level'|trans }}</label>
          <select id="filter-risk" name="filter-risk" class="w-full">
            <option value="">{{ 'Any'|trans }}</option>
            <option value="low">{{ 'Low'|trans }}</option>
            <option value="medium">{{ 'Medium'|trans }}</option> {# Предполагаем, что API "neutral" это medium #}
            <option value="high">{{ 'High'|trans }}</option>
          </select>
        </div>

        {# Columns #}
        <fieldset>
            <legend class="e-h4 mt-2l mb-s">{{ 'Columns'|trans }}</legend>
            <ul class="e-list is-unstyled grid phone:2-columns gap-s" id="filter-columns-list">
              {# Сюда JS будет вставлять чекбоксы для колонок.
                 Можно и в Twig, но для динамического управления из JS так проще.
                 Для примера, как это могло бы выглядеть в Twig:
              {% for col_conf in default_columns %}
                {% set fixed_columns = ['asset', 'price'] %}
                <li>
                  <label>
                    <input
                      type="checkbox"
                      name="column-{{ col_conf.key }}"
                      value="{{ col_conf.key }}"
                      {% if col_conf.key in fixed_columns %}checked disabled{% elseif col_conf.visible is not defined or col_conf.visible %}checked{% endif %}
                    >
                    {{ col_conf.label|trans }}
                  </label>
                </li>
              {% endfor %}
              #}
            </ul>
        </fieldset>
      </form>
    </div>
    <div class="e-drawer__footer sticky">
      <button class="e-btn" type="button" data-role="close-drawer">
        {{ 'Cancel'|trans }}
      </button>
      <button class="e-btn is-primary" type="submit" form="filters-form">
        {{ 'Apply'|trans }}
      </button>
    </div>
  </dialog>

  <script>
    /* eslint-disable no-use-before-define, no-console */
    (() => {
      // -----------------------------------------------------------------------
      // НАСТРОЙКИ
      // -----------------------------------------------------------------------
      const API_URL = '{{ api_url|escape("js") }}';
      const IS_DEVELOPMENT = '{{ ENV }}' === 'development';

      // 10 секунд
      const REFRESH_INTERVAL_MS = 10000;

      // Переменная в пути к картинкам, стилям и скриптам из Twig
      const ASSETS_PATH_PREFIX = '{{ site.assets_prefix|escape("js") }}';

      // Высота строки в px для виртуализации
      const ROW_HEIGHT_ESTIMATE = 56;

      // Количество строк сверху/снизу от видимой области для рендера
      const VISIBLE_BUFFER = 5;

      // Метаданные для криптовалют (Названия, пути к иконкам)
      // Загружаются из внешнего файла. Ключ - символ в ВЕРХНЕМ РЕГИСТРЕ
      let cryptoMeta = {};

      fetch(`${ASSETS_PATH_PREFIX}/assets/data/crypto-meta.json`)
        .then((response) => response.json())
        .then((data) => {
          cryptoMeta = data;
        })
        .catch((error) => {
          if (IS_DEVELOPMENT) {
            console.error('Failed to load crypto metadata:', error);
          }

          cryptoMeta = {
            BTC: { name: 'Bitcoin', icon: 'btc.svg' },
            ETH: { name: 'Ethereum', icon: 'eth.svg' },
            SOL: { name: 'Solana', icon: 'sol.svg' },
            AVAX: { name: 'Avalanche', icon: 'avax.svg' },
            BONK: { name: 'Bonk', icon: 'bonk.svg' },
            DOGE: { name: 'Dogecoin', icon: 'doge.svg' },
            BNB: { name: 'BNB', icon: 'bnb.svg' },
          };
        });

      // -----------------------------------------------------------------------
      // КОНФИГУРАЦИЯ КОЛОНОК (Добавляем все возможные из API)
      // -----------------------------------------------------------------------
      // `apiField` - ключ в данных API. `visible` - начальное состояние.
      // `canHide` - можно ли скрыть колонку.
      // `label` будет браться из этой конфигурации для генерации чекбоксов
      const ALL_COLUMNS_CONFIG = [
        {
          key: 'watchlist',
          type: 'action',
          label: '{{ "Watchlist"|trans|escape("js") }}',
          sortable: false,
          visible: false,
          canHide: true,
          apiField: 'watchlist',
        },
        {
          key: 'asset',
          type: 'text',
          label: '{{ "Asset"|trans|escape("js") }}',
          sortable: true,
          apiField: 'symbol',
          visible: true,
          canHide: false,
        },
        {
          key: 'price',
          type: 'num',
          label: '{{ "Price, $"|trans|escape("js") }}',
          sortable: true,
          apiField: 'price.current',
          formatter: formatPrice,
          visible: true,
          canHide: false,
        },
        {
          key: 'change_24h',
          type: 'num',
          label: '{{ "Chg (24H), %"|trans|escape("js") }}',
          sortable: true,
          apiField: 'price',
          formatter: formatChange24h,
          visible: true,
          canHide: true,
        },
        {
          key: 'rating',
          type: 'num',
          label: '{{ "Rating"|trans|escape("js") }}',
          sortable: true,
          apiField: 'rating',
          formatter: formatNullable,
          visible: true,
          canHide: true,
        },
        {
          key: 'risk',
          type: 'icon',
          label: '{{ "Risk"|trans|escape("js") }}',
          sortable: false,
          apiField: 'risk',
          formatter: formatRisk,
          visible: true,
          canHide: true,
        },
        {
          key: 'trindex',
          type: 'num',
          label: '{{ "TRIndex"|trans|escape("js") }}',
          sortable: true,
          apiField: 'TRINDX',
          formatter: formatNullable,
          visible: true,
          canHide: true,
        },
        {
          key: 'rsi_7d',
          type: 'num',
          label: '{{ "RSI (7D)"|trans|escape("js") }}',
          sortable: true,
          apiField: 'RSI7',
          formatter: formatNullable,
          visible: true,
          canHide: true,
        }, // Изменил key для уникальности
        {
          key: 'rsi_30d',
          type: 'num',
          label: '{{ "RSI (30D)"|trans|escape("js") }}',
          sortable: true,
          apiField: 'RSI30',
          formatter: formatNullable,
          visible: false,
          canHide: true,
        },
        {
          key: 'rsi_91d',
          type: 'num',
          label: '{{ "RSI (91D)"|trans|escape("js") }}',
          sortable: true,
          apiField: 'RSI91',
          formatter: formatNullable,
          visible: false,
          canHide: true,
        },
        {
          key: 'rsi_182d',
          type: 'num',
          label: '{{ "RSI (182D)"|trans|escape("js") }}',
          sortable: true,
          apiField: 'RSI182',
          formatter: formatNullable,
          visible: false,
          canHide: true,
        },
        {
          key: 'rsi_365d',
          type: 'num',
          label: '{{ "RSI (365D)"|trans|escape("js") }}',
          sortable: true,
          apiField: 'RSI365',
          formatter: formatNullable,
          visible: false,
          canHide: true,
        },
        {
          key: 'rsi_1000d',
          type: 'num',
          label: '{{ "RSI (1000D)"|trans|escape("js") }}',
          sortable: true,
          apiField: 'RSI1000',
          formatter: formatNullable,
          visible: false,
          canHide: true,
        },
        {
          key: 'market',
          type: 'text',
          label: '{{ "Market"|trans|escape("js") }}',
          sortable: true,
          apiField: 'market',
          formatter: formatNullable,
          visible: false,
          canHide: true,
        },
        {
          key: 'chart',
          type: 'action',
          label: '{{ "Chart"|trans|escape("js") }}',
          sortable: false,
          visible: false,
          canHide: true,
          apiField: 'chart_data',
        },
      ];

      // Текущая конфигурация колонок, которая будет меняться
      let columnsConfig = ALL_COLUMNS_CONFIG.map(col => ({ ...col }));

      // Динамически обновляемые переменные на основе columnsConfig
      let visibleColumns = columnsConfig.filter((c) => c.visible);
      let visibleColumnsCount = visibleColumns.length;

      // -----------------------------------------------------------------------
      // СОСТОЯНИЕ
      // -----------------------------------------------------------------------
      let allAssets = [];

      // Отсортированный массив для рендеринга
      let sortedFilteredAssets = [];
      const sortState = {
        field: '{{ initial_sort_field|escape("js") }}',
        direction: '{{ initial_sort_direction|escape("js") }}',
      };

      // Начальное состояние фильтров
      const initialFilterState = {
        priceMin: null,
        priceMax: null,
        rsiMin: null, // Для RSI7
        rsiMax: null, // Для RSI7
        ratingMax: null, // "до X", т.е. значение <= X
        risk: '', // 'low', 'medium', 'high' или '' для всех
        // visibleColumnKeys будет заполнено из columnsConfig в initFilters
      };
      let currentFilterState = JSON.parse(JSON.stringify(initialFilterState));
      currentFilterState.visibleColumnKeys = columnsConfig
        .filter((c) => c.visible)
        .map((c) => c.key);

      let updateIntervalId = null;
      let isLoading = true;
      let currentRequestController = null;

      // -----------------------------------------------------------------------
      // DOM ЭЛЕМЕНТЫ
      // -----------------------------------------------------------------------
      const scrollContainer = document.getElementById('virtual-scroll-container');
      const table = document.getElementById('crypto-table');

      // Добавим ссылку на thead
      const tableHead = table.querySelector('thead');
      const tableBody = document.getElementById('crypto-table-body');
      const loadingRow = document.getElementById('loading-row');

      // sortButtons будет переопределен в generateTableHeadHtml
      let sortButtons = [];
      const screenReaderAnnouncer = document.getElementById(
        'screen-reader-announcement'
      );
      const drawerFilter = document.getElementById('drawer-filter');
      const filtersForm = document.getElementById('filters-form');
      const filterColumnsList = document.getElementById('filter-columns-list');
      const filterToggleButton = document.querySelector(
        '[data-target="drawer-filter"]'
      );

      // -----------------------------------------------------------------------
      // ФОРМАТИРОВАНИЕ ДАННЫХ
      // -----------------------------------------------------------------------

      function formatPrice(value) {
        if (value === null || value === undefined) return '–';
        const price = parseFloat(value);
        if (Number.isNaN(price)) return '–';
        // Для очень маленьких значений используем экспоненциальную запись
        if (price < 0.00000001 && price > 0) return price.toExponential(2);
        // Для значений меньше 1 используем до 8 знаков после запятой
        if (price < 1) {
          // Находим первую значащую цифру после запятой
          const sigDigit = (price.toString().split('.')[1] || '').search(/[^0]/);
          // Используем максимум 8 знаков, но не меньше, чем до первой значащей цифры + 2
          return price.toFixed(Math.min(8, Math.max(sigDigit + 2, 2)));
        }
        // Для больших значений оставляем 2 знака после запятой
        return price.toLocaleString('en-US', {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        });
      }

      function formatChange24h(priceData) {
        if (
          !priceData ||
          priceData.current === undefined ||
          priceData.yesterday?.middle === undefined
        )
          return '–';
        const current = parseFloat(priceData.current);
        const yesterdayMiddle = parseFloat(priceData.yesterday.middle);
        if (
          Number.isNaN(current) ||
          Number.isNaN(yesterdayMiddle) ||
          yesterdayMiddle === 0
        )
          return '–';
        const change = ((current - yesterdayMiddle) / yesterdayMiddle) * 100;
        const sign = change > 0 ? '+' : '';
        return `${sign}${change.toFixed(2)}`;
      }

      function formatRisk(value) {
        const riskLower = (value || '').toLowerCase();
        switch (riskLower) {
          case 'high': {
            return `<span class="has-tooltip" aria-label="{{ "High risk"|trans|escape("js") }}"><svg class="e-icon is-error" aria-hidden="true" focusable="false"><use xlink:href="${
              ASSETS_PATH_PREFIX
            }/assets/img/icons/sprite.svg#icon-error"></use></svg></span>`;
          }
          case 'medium': // API may return 'neutral', mapping both to medium
          case 'neutral': {
            return `<span class="has-tooltip" aria-label="{{ "Medium risk"|trans|escape("js") }}"><svg class="e-icon is-yin-yang" aria-hidden="true" focusable="false"><use xlink:href="${
              ASSETS_PATH_PREFIX
            }/assets/img/icons/sprite.svg#icon-yin-yang"></use></svg></span>`;
          }
          case 'low': {
            return `<span class="has-tooltip" aria-label="{{ "Low risk"|trans|escape("js") }}"><svg class="e-icon is-success" aria-hidden="true" focusable="false"><use xlink:href="${
              ASSETS_PATH_PREFIX
            }/assets/img/icons/sprite.svg#icon-success"></use></svg></span>`;
          }
          default: {
            return '<span aria-label="{{ "No risk data"|trans|escape("js") }}">–</span>';
          }
        }
      }

      function formatNullable(value) {
        return value !== null && value !== undefined ? value : '–';
      }

      // -----------------------------------------------------------------------
      // ПОЛУЧЕНИЕ И ОБРАБОТКА ДАННЫХ
      // -----------------------------------------------------------------------

      // Функция для получения значения из вложенного объекта (например, 'price.current')
      const getNestedValue = (obj, path) => {
        if (!obj || !path) return null;
        return path.split('.').reduce((acc, part) => (acc ? acc[part] : null), obj);
      };

      // Cleanup function to clear interval
      const cleanup = () => {
        if (updateIntervalId) {
          clearInterval(updateIntervalId);
          updateIntervalId = null;
        }
      };

      /**
      * Асинхронная функция для получения котировок и индексов криптовалют через API или локальный JSON
      *
      * 1. Отменяет предыдущий незавершенный запрос, если он существует
      * 2. Формирует параметры запроса в зависимости от окружения (development/production)
      * 3. Определяет язык из URL и формирует полный URL для запроса
      * 4. Выполняет fetch-запрос и обрабатывает ответ
      * 5. В случае получения HTML вместо JSON (например, страница авторизации) перенаправляет на страницу входа
      * 6. Обрабатывает полученные данные через функцию processData
      * 7. Управляет состоянием загрузки и отображением индикатора
      * 8. Обрабатывает ошибки и отображает соответствующие сообщения
      *
      * @async
      * @throws {Error} Если запрос завершился с ошибкой или получен неверный формат данных
      * @returns {Promise<void>}
      */
      async function fetchData() {
        if (currentRequestController) {
          currentRequestController.abort();
        }

        currentRequestController = new AbortController();

        try {
          // В development используем GET для local JSON, в production - POST для API
          const options = IS_DEVELOPMENT
            ? { method: 'GET', signal: currentRequestController.signal }
            : {
                method: 'POST',
                body: JSON.stringify({ jsonfather: true }),
                headers: { 'Content-Type': 'application/json' },
                // Вместе с запросом отправляем cookies
                credentials: 'include',
                signal: currentRequestController.signal,
              };

          // Получаем текущий язык из URL
          const currentLang = window.location.pathname
            .split('/')[1]
            ?.match(/^[a-z]{2}$/)
            ? window.location.pathname.split('/')[1]
            : '';

          // Формируем полный URL с учетом языка
          const fullApiUrl = IS_DEVELOPMENT
            ? API_URL
            : `${window.location.origin}/${currentLang ? `${currentLang}/` : ''}json/trindxrating`;

          const response = await fetch(fullApiUrl, options);

          if (!response.ok) {
            // Проверяем, не HTML ли получен вместо JSON
            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('text/html')) {
              // Получен HTML вместо JSON - вероятно, страница авторизации
              window.location.href = `/auth?returl=${encodeURIComponent(window.location.pathname)}`;
              return;
            }
            throw new Error(
              `{{ "Something went wrong while loading the page."|trans|escape("js") }} status: ${response.status}`
            );
          }

          const data = await response.json();
          processData(data);

          if (isLoading) {
            isLoading = false;
            table.setAttribute('aria-busy', 'false');
            loadingRow?.remove();
          }

          announceUpdate('{{ "Table data updated."|trans|escape("js") }}');
        } catch (error) {
          // Stop polling on critical errors
          cleanup();
          if (error.name === 'AbortError') {
            if (IS_DEVELOPMENT) {
              console.log('Fetch aborted');
            }
            return;
          }

          if (IS_DEVELOPMENT) {
            console.error('Failed to fetch crypto data:', error);
          }
          displayErrorState(
            `{{ "Data couldn’t be loaded. Try again soon."|trans|escape("js") }} ${error.message}`
          );
        } finally {
          currentRequestController = null;
        }
      }

      /**
      * Обрабатывает данные, полученные от API, и подготавливает их для отображения в таблице.
      *
      * @param {Object|Array} responseData - Данные, полученные от API. В режиме разработки - объект,
      *                                     в продакшене - массив [status, data].
      *
      * @description
      * 1. Проверяет формат полученных данных в зависимости от окружения (разработка/продакшн)
      * 2. Валидирует структуру данных
      * 3. Преобразует данные в унифицированный формат для каждого криптоактива
      * 4. Добавляет метаданные (имя, иконку) из cryptoMeta
      * 5. Обрабатывает случаи с некорректными данными, предоставляя значения по умолчанию
      * 6. Обновляет UI и состояние загрузки
      * 7. Применяет сортировку и фильтрацию
      * 8. Отрисовывает таблицу
      *
      * @throws {void} Не выбрасывает исключений, но может вызвать displayErrorState при некорректных данных
      */
      const processData = (responseData) => {
        let apiData;

        if (IS_DEVELOPMENT) {
          // Для разработки данные уже в нужном формате объекта
          apiData = responseData;
        } else {
          const [status, data] = responseData;
          if (
            !Array.isArray(responseData) ||
            responseData.length < 2 ||
            status !== 'OK'
          ) {
            displayErrorState(
              '{{ "Server sent data in an unexpected format."|trans|escape("js") }}'
            );
            return;
          }
          apiData = data;
        }

        if (!apiData || typeof apiData !== 'object') {
          if (IS_DEVELOPMENT) {
            console.error(
              'apiData is not an object after initial processing:',
              apiData
            );
          }
          displayErrorState(
            '{{ "No valid asset data available."|trans|escape("js") }}'
          );
          return;
        }

        const symbols = Object.keys(apiData);
        allAssets = symbols
          .map((symbol) => {
            const upperSymbol = symbol.toUpperCase();
            const meta = cryptoMeta[upperSymbol] || {
              name: symbol, // Имя по умолчанию - символ, если нет в cryptoMeta
              icon: null,
            };
            const assetData = apiData[symbol];

            if (typeof assetData !== 'object' || assetData === null) {
              if (IS_DEVELOPMENT) {
                console.warn(
                  `The data for symbol ${symbol} is not an object or is null:`,
                  assetData
                );
              }
              // Возвращаем объект с полями по умолчанию, чтобы избежать ошибок в renderTable и formatters
              return {
                symbol: upperSymbol,
                name: meta.name,
                icon: meta.icon
                  ? `${ASSETS_PATH_PREFIX}/assets/img/cryptologos/${meta.icon}`
                  : null,
                watchlist: false, // Стандартное значение по умолчанию
                chart_data: [], // Стандартное значение по умолчанию
                id: symbol, // ID актива

                // Поля, которые обычно приходят из assetData, но теперь устанавливаются по умолчанию
                // Важно, чтобы price был объектом, даже если его поля null,
                // чтобы функции типа formatPrice(asset.price.current) не вызывали ошибок.
                price: {
                  current: null,
                  yesterday: { middle: null },
                  // Можно добавить и другие поля из price, если они используются, например 'today'
                  // today: { min: null, max: null, middle: null }
                },
                rating: null,
                risk: null, // Для formatRisk, который обработает null
                TRINDX: null,
                RSI7: null,
                // Если есть другие поля из 'assetData', которые напрямую используются в formatters
                // или в generateTableRowHtml, их тоже нужно здесь указать с значением null или подходящим дефолтом.
                // Например, если бы использовалось поле 'market':
                // market: null,

                // Поля из API, не используемые в видимых колонках по умолчанию, но могущие быть в assetData:
                // RSI1000: null,
                // RSI365: null,
                // и т.д. - их можно опустить, если они не нужны для рендеринга или сортировки скрытых колонок
              };
            }

            // Если assetData - валидный объект, используем его данные
            return {
              symbol: upperSymbol,
              name: meta.name,
              icon: meta.icon
                ? `${ASSETS_PATH_PREFIX}/assets/img/cryptologos/${meta.icon}`
                : null,
              // Стандартное значение по умолчанию
              watchlist: false,
              // Стандартное значение по умолчанию
              chart_data: [],
              // ID актива
              id: symbol,
              // Распространяем все данные из API для этого символа
              ...assetData,
            };
            // Отфильтровываем возможные некорректные записи (например, если map вернул null)
          })
          .filter((asset) => asset && asset.symbol);

        // Если это первая загрузка, обновляем состояние UI сначала
        if (isLoading) {
          isLoading = false;
          table.setAttribute('aria-busy', 'false');
          loadingRow?.remove();
          announceUpdate(
            '{{ "All data has been successfully loaded."|trans|escape("js") }}'
          );
        }

        applySortAndFilter();
        renderTable();

        if (!isLoading) {
          announceUpdate('{{ "The data has been updated."|trans|escape("js") }}');
        }
      };

      /**
      * Отображает состояние ошибки в таблице
      * @param {string} message - Сообщение об ошибке для отображения
      * @description
      * - Вставляет строку с сообщением об ошибке в тело таблицы
      * - Добавляет кнопку повторной попытки
      * - Снимает индикатор загрузки с таблицы
      * - Скрывает строку загрузки, если она присутствует
      * - Сбрасывает флаг состояния загрузки
      */
      function displayErrorState(message) {
        tableBody.innerHTML = `
              <tr>
                <td class="table__cell is-empty-state is-error-state" colspan="${visibleColumnsCount}">
                  <p>${message}</p>
                  <button class="e-btn is-text" onclick="location.reload()">{{ "Retry"|trans|escape("js") }}</button>
                </td>
              </tr>`;
        // Снимаем состояние занятости при ошибке
        table.setAttribute('aria-busy', 'false');
        // Скрываем строку загрузки если она еще есть
        if (loadingRow) loadingRow.style.display = 'none';

        // Считаем загрузку завершенной (с ошибкой)
        isLoading = false;
      }

      // -----------------------------------------------------------------------
      // ФИЛЬТРЫ И КОЛОНКИ
      // -----------------------------------------------------------------------
      function populateColumnCheckboxes() {
        filterColumnsList.innerHTML = '';
        columnsConfig.forEach((col) => {
          const listItem = document.createElement('li');
          const label = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.name = 'column-filter';
          checkbox.value = col.key;
          checkbox.checked = col.visible;
          if (!col.canHide) {
            checkbox.disabled = true;
          }
          checkbox.addEventListener('change', handleColumnVisibilityChange);

          label.appendChild(checkbox);
          label.appendChild(document.createTextNode(` ${col.label}`));
          listItem.appendChild(label);
          filterColumnsList.appendChild(listItem);
        });
      }

      function handleColumnVisibilityChange(event) {
        const changedKey = event.target.value;
        const isVisible = event.target.checked;

        const columnIndex = columnsConfig.findIndex((c) => c.key === changedKey);
        if (columnIndex > -1) {
          columnsConfig[columnIndex].visible = isVisible;
        }

        // Обновляем производные переменные
        visibleColumns = columnsConfig.filter((c) => c.visible);
        visibleColumnsCount = visibleColumns.length;
        currentFilterState.visibleColumnKeys = visibleColumns.map((c) => c.key);

        // Немедленно перерисовываем заголовок и таблицу
        generateTableHeadHtml();
        applySortAndFilter(false);
        updateFilterCountBadge();
      }

      function applyFiltersAndDraw() {
        // 1. Прочитать значения из формы в currentFilterState
        currentFilterState.priceMin =
          parseFloat(filtersForm.elements['filter-price-min'].value) || null;
        currentFilterState.priceMax =
          parseFloat(filtersForm.elements['filter-price-max'].value) || null;
        currentFilterState.rsiMin =
          parseFloat(filtersForm.elements['filter-rsi-min'].value) || null;
        currentFilterState.rsiMax =
          parseFloat(filtersForm.elements['filter-rsi-max'].value) || null;
        currentFilterState.ratingMax =
          parseFloat(filtersForm.elements['filter-rating-max'].value) || null;
        currentFilterState.risk = filtersForm.elements['filter-risk'].value || '';

        // Валидация: если min > max, поменять их местами или обнулить max
        if (
          currentFilterState.priceMin &&
          currentFilterState.priceMax &&
          currentFilterState.priceMin > currentFilterState.priceMax
        ) {
          [currentFilterState.priceMin, currentFilterState.priceMax] = [
            currentFilterState.priceMax,
            currentFilterState.priceMin,
          ];
          // Обновить поля в UI
          filtersForm.elements['filter-price-min'].value =
            currentFilterState.priceMin;
          filtersForm.elements['filter-price-max'].value =
            currentFilterState.priceMax;
        }
        if (
          currentFilterState.rsiMin &&
          currentFilterState.rsiMax &&
          currentFilterState.rsiMin > currentFilterState.rsiMax
        ) {
          [currentFilterState.rsiMin, currentFilterState.rsiMax] = [
            currentFilterState.rsiMax,
            currentFilterState.rsiMin,
          ];
          filtersForm.elements['filter-rsi-min'].value = currentFilterState.rsiMin;
          filtersForm.elements['filter-rsi-max'].value = currentFilterState.rsiMax;
        }

        // 2. Применить фильтры и сортировку
        applySortAndFilter(true);

        // 3. Обновить значок счетчика
        updateFilterCountBadge();

        // 4. Закрыть панель
        if (drawerFilter.close) drawerFilter.close();
      }

      function resetFiltersAndDraw() {
        // Сбрасываем поля формы
        filtersForm.reset();
        currentFilterState = JSON.parse(JSON.stringify(initialFilterState));

        // Сбросить видимость колонок к начальному состоянию
        columnsConfig = ALL_COLUMNS_CONFIG.map(col => ({ ...col }));

        visibleColumns = columnsConfig.filter((c) => c.visible);
        visibleColumnsCount = visibleColumns.length;
        currentFilterState.visibleColumnKeys = visibleColumns.map((c) => c.key);

        // Обновить чекбоксы в UI, заголовок таблицы
        populateColumnCheckboxes();
        generateTableHeadHtml();
        applySortAndFilter(true);
        updateFilterCountBadge();
        if (drawerFilter.close) drawerFilter.close();
      }

      function updateFilterCountBadge() {
        let count = 0;
        if (
          currentFilterState.priceMin !== null ||
          currentFilterState.priceMax !== null
        )
          count += 1;
        if (
          currentFilterState.rsiMin !== null ||
          currentFilterState.rsiMax !== null
        )
          count += 1;
        if (currentFilterState.ratingMax !== null) count += 1;
        if (currentFilterState.risk) count += 1;

        // Считаем не дефолтные видимые колонки
        const defaultVisibleKeys = ALL_COLUMNS_CONFIG.filter((c) => c.visible).map(
          (c) => c.key
        );
        const currentVisibleKeys = columnsConfig
          .filter((c) => c.visible)
          .map((c) => c.key);
        if (
          JSON.stringify(defaultVisibleKeys.sort()) !==
          JSON.stringify(currentVisibleKeys.sort())
        ) {
          count += 1;
        }

        filterToggleButton.innerHTML = `
              {% include 'partials/icon.twig' with {name: 'filter'} %}
              {{ 'Filters'|trans }} ${count}
            `;
      }

      filtersForm.addEventListener('submit', (event) => {
        event.preventDefault();
        applyFiltersAndDraw();
      });

      // -----------------------------------------------------------------------
      // ГЕНЕРАЦИЯ ЗАГОЛОВКА ТАБЛИЦЫ
      // -----------------------------------------------------------------------
      function generateTableHeadHtml() {
        let headHtml = '<tr>';
        visibleColumns.forEach((col) => {
          const { label } = col;
          const thClasses = `table__cell is-${col.type}${col.key === 'watchlist' || col.key === 'chart' ? ' is-action' : ''}`;
          let thContent = label;
          let ariaLabelAttr =
            col.type === 'action' || col.type === 'icon'
              ? `aria-label="${label}"`
              : '';

          if (col.sortable) {
            const isActive = sortState.field === col.key;
            const isDesc = isActive && sortState.direction === 'desc';
            let ariaSort = 'none';
            if (isActive) {
              ariaSort = sortState.direction === 'asc' ? 'ascending' : 'descending';
            }
            thContent = `
                  <button
                    class="e-btn is-sort ${isActive ? 'is-active' : ''} ${isDesc ? 'is-desc' : ''}"
                    type="button"
                    data-sort-field="${col.key}"
                    aria-label="{{ 'Sort by this column'|trans|escape('js') }}"
                    aria-sort="${ariaSort}"
                  >
                    ${label}
                    {% include 'partials/icon.twig' with {name: 'up'} %}
                  </button>`;
            // aria-label на кнопке, а не на th
            ariaLabelAttr = '';
          }
          headHtml += `<th class="${thClasses}" scope="col" ${ariaLabelAttr}>${thContent}</th>`;
        });
        headHtml += '</tr>';
        tableHead.innerHTML = headHtml;

        // Переназначаем обработчики на новые кнопки сортировки
        sortButtons = tableHead.querySelectorAll(
          'thead th button[data-sort-field]'
        );
        sortButtons.forEach((button) => {
          button.addEventListener('click', handleSortClick);
        });
      }

      // -----------------------------------------------------------------------
      // СОРТИРОВКА
      // -----------------------------------------------------------------------
      function handleSortClick(event) {
        const button = event.currentTarget;
        const field = button.dataset.sortField;

        let direction = 'asc';
        if (sortState.field === field && sortState.direction === 'asc') {
          direction = 'desc';
        }

        sortState.field = field;
        sortState.direction = direction;

        // Обновляем ARIA атрибуты и классы кнопок
        sortButtons.forEach((btn) => {
          const btnField = btn.dataset.sortField;
          if (btnField === field) {
            btn.classList.add('is-active');
            btn.classList.toggle('is-desc', direction === 'desc');
            btn.setAttribute(
              'aria-sort',
              direction === 'asc' ? 'ascending' : 'descending'
            );
          } else {
            btn.classList.remove('is-active', 'is-desc');
            btn.setAttribute('aria-sort', 'none');
          }
        });

        // Пересортировать и перерисовать
        applySortAndFilter();
        announceUpdate(
          // eslint-disable-next-line prefer-template
          '{{ "Table sorted by"|trans|escape("js") }} ' +
            (columnsConfig.find((c) => c.key === field)?.label || field) +
            (direction === 'asc'
              ? ' {{ "ascending"|trans|escape("js") }}'
              : ' {{ "descending"|trans|escape("js") }}')
        );
      }

      /**
      * Применяет текущие фильтры и сортировку к allAssets, обновляет sortedFilteredAssets и перерисовывает таблицу.
      * @param {boolean} [resetScroll=true] - Сбрасывать ли позицию скролла.
      */
      function applySortAndFilter(resetScroll = true) {
        if (!Array.isArray(allAssets)) {
          if (IS_DEVELOPMENT) console.error('allAssets is not an array');
          return;
        }

        // 1. Фильтрация
        const filteredData = allAssets.filter((asset) => {
          // Цена
          if (
            currentFilterState.priceMin !== null &&
            (asset.price?.current === null ||
              asset.price.current < currentFilterState.priceMin)
          )
            return false;
          if (
            currentFilterState.priceMax !== null &&
            (asset.price?.current === null ||
              asset.price.current > currentFilterState.priceMax)
          )
            return false;

          // RSI (7D) - используем apiField из columnsConfig для rsi_7d
          const rsi7dConfig = columnsConfig.find((c) => c.key === 'rsi_7d');
          const rsiValue = rsi7dConfig
            ? getNestedValue(asset, rsi7dConfig.apiField)
            : null;

          if (
            currentFilterState.rsiMin !== null &&
            (rsiValue === null || parseFloat(rsiValue) < currentFilterState.rsiMin)
          )
            return false;
          if (
            currentFilterState.rsiMax !== null &&
            (rsiValue === null || parseFloat(rsiValue) > currentFilterState.rsiMax)
          )
            return false;

          // Рейтинг (меньше или равно)
          if (
            currentFilterState.ratingMax !== null &&
            (asset.rating === null || asset.rating > currentFilterState.ratingMax)
          )
            return false;

          // Риск
          if (currentFilterState.risk) {
            let assetRisk = (asset.risk || '').toLowerCase();
            // API может вернуть "neutral", который мы считаем "medium"
            if (assetRisk === 'neutral') assetRisk = 'medium';
            if (assetRisk !== currentFilterState.risk) return false;
          }
          return true;
        });

        // 2. Сортировка (применяется к filteredData)
        // Копируем отфильтрованные данные для сортировки
        const dataToSort = [...filteredData];
        const sortConfig = columnsConfig.find((c) => c.key === sortState.field);

        // Если текущее поле сортировки было скрыто, сбрасываем на 'asset'
        if (sortConfig && !sortConfig.visible) {
          sortState.field = 'asset';
          sortState.direction = 'asc';
          // Обновить кнопки сортировки в UI (сбросить активное состояние)
           // Это перерисует заголовки с правильными активными состояниями
          generateTableHeadHtml();
        }
        // Повторно получаем sortConfig на случай, если он изменился
        const currentSortConfig = columnsConfig.find(
          (c) => c.key === sortState.field
        );
        const apiField = currentSortConfig?.apiField || sortState.field;

        dataToSort.sort((a, b) => {
          // ... (существующая логика сортировки из вашего applySortAndFilter, но valA/valB берутся из apiField)
          // ... (убедитесь, что getNestedValue(a, apiField) используется правильно)
          let valA = getNestedValue(a, apiField);
          let valB = getNestedValue(b, apiField);

          if (sortState.field === 'asset') {
            valA = a.name?.toLowerCase() || '';
            valB = b.name?.toLowerCase() || '';
          } else if (sortState.field === 'change_24h') {
            const changeA = calculateChange24hValue(a.price);
            const changeB = calculateChange24hValue(b.price);
            valA = (() => {
              if (changeA === null) {
                return sortState.direction === 'asc' ? Infinity : -Infinity;
              }
              return changeA;
            })();
            valB =
              changeB === null
                ? (sortState.direction === 'asc' ? 1 : -1) * Infinity
                : changeB;
          } else {
            const numA = parseFloat(valA);
            const numB = parseFloat(valB);
            if (!Number.isNaN(numA) && !Number.isNaN(numB)) {
              valA = numA;
              valB = numB;
            } else if (typeof valA === 'string' && typeof valB === 'string') {
              valA = valA.toLowerCase();
              valB = valB.toLowerCase();
            }
          }

          const aIsNull =
            valA === null ||
            valA === undefined ||
            valA === Infinity ||
            valA === -Infinity;
          const bIsNull =
            valB === null ||
            valB === undefined ||
            valB === Infinity ||
            valB === -Infinity;

          if (aIsNull && bIsNull) return 0;
          // Для числовых полей, null/undefined значения идут в конец при asc, в начало при desc
          // Для строковых, они уже обработаны toLowerCase() или как пустые строки
          if (
            typeof valA === 'number' ||
            typeof valB === 'number' ||
            valA === Infinity ||
            valA === -Infinity ||
            valB === Infinity ||
            valB === -Infinity
          ) {
            if (aIsNull) return sortState.direction === 'asc' ? 1 : -1;
            if (bIsNull) return sortState.direction === 'asc' ? -1 : 1;
          }

          if (valA < valB) return sortState.direction === 'asc' ? -1 : 1;
          if (valA > valB) return sortState.direction === 'asc' ? 1 : -1;
          return 0;
        });

        sortedFilteredAssets = dataToSort;

        if (resetScroll) {
          scrollContainer.scrollTop = 0;
        }

        // Перерисовать таблицу с отфильтрованными и отсортированными данными
        renderTable();
      }

      // Вспомогательная функция для получения числового значения изменения 24ч
      const calculateChange24hValue = (priceData) => {
        if (!priceData?.current || !priceData?.yesterday?.middle) {
          return null;
        }

        const current = parseFloat(priceData.current);
        const yesterdayMiddle = parseFloat(priceData.yesterday.middle);

        if (
          Number.isNaN(current) ||
          Number.isNaN(yesterdayMiddle) ||
          yesterdayMiddle === 0
        ) {
          return null;
        }

        return ((current - yesterdayMiddle) / yesterdayMiddle) * 100;
      };

      // -----------------------------------------------------------------------
      // РЕНДЕРИНГ (ВИРТУАЛИЗАЦИЯ)
      // -----------------------------------------------------------------------
      function renderTable() {
        // Не рендерим, пока не загрузились данные
        if (isLoading) return;

        const totalItems = sortedFilteredAssets.length;

        if (totalItems === 0) {
          tableBody.innerHTML = `
                <tr>
                  <td class="table__cell is-empty-state" colspan="${visibleColumnsCount}">
                    <p>{{ "No data available"|trans|escape("js") }}</p>
                  </td>
                </tr>`;
          return;
        }

        const { scrollTop } = scrollContainer;
        const containerHeight = scrollContainer.clientHeight;

        // Рассчитываем индексы видимых элементов
        const startIndex = Math.max(
          0,
          Math.floor(scrollTop / ROW_HEIGHT_ESTIMATE) - VISIBLE_BUFFER
        );
        const endIndex = Math.min(
          totalItems,
          Math.ceil((scrollTop + containerHeight) / ROW_HEIGHT_ESTIMATE) +
            VISIBLE_BUFFER
        );

        // Создаем HTML для видимых строк
        let visibleRowsHtml = '';
        for (let i = startIndex; i < endIndex; i++) {
          visibleRowsHtml += generateTableRowHtml(sortedFilteredAssets[i]);
        }

        // Рассчитываем высоту верхнего и нижнего спейсеров
        const topSpacerHeight = startIndex * ROW_HEIGHT_ESTIMATE;
        const bottomSpacerHeight = (totalItems - endIndex) * ROW_HEIGHT_ESTIMATE;

        // Обновляем содержимое tbody
        tableBody.innerHTML = `
              <tr style="height: ${topSpacerHeight}px;"><td colspan="${visibleColumnsCount}" style="padding:0; border:0;"></td></tr>
              ${visibleRowsHtml}
              <tr style="height: ${bottomSpacerHeight}px;"><td colspan="${visibleColumnsCount}" style="padding:0; border:0;"></td></tr>
            `;

        // Restore focus to table if it was previously focused
        const focusedElement = document.activeElement;
        if (table.contains(focusedElement)) {
          table.focus();
        }
      }

      function generateTableRowHtml(asset) {
        if (!asset || typeof asset !== 'object') {
          if (IS_DEVELOPMENT) {
            console.error('Invalid asset data');
          }
          return '';
        }

        // Уникальный ID для строки
        const rowId = `asset-row-${asset.symbol}`;
        let cellsHtml = '';
        visibleColumns.forEach((col) => {
          let cellContent = '';
          let cellClasses = `table__cell is-${col.type}`;
          const attributes = '';

          switch (col.key) {
            case 'watchlist': // Скрыто
              // cellContent = `<button class="e-btn is-watchlist" type="button" ...></button>`;
              cellClasses += ' is-action';
              break;
            case 'asset': {
              const iconPath = asset.icon;

              // Фолбэк иконка
              const fallbackIcon = `<span class="e-asset__icon-fallback" aria-hidden="true">${asset.symbol.substring(0, 3)}</span>`;

              // onerror для показа фоллбэка
              const imgTag = `<img class="e-asset__icon" src="${iconPath}" alt="" loading="lazy" width="32" height="32" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';">`;
              cellContent = `
                    <div class="e-asset">
                        <div class="e-asset__copy">
                            <span class="e-asset__name">${asset.name}</span>
                            <span class="e-asset__symbol">${asset.symbol}</span>
                        </div>
                        ${iconPath ? imgTag : ''}
                        ${fallbackIcon}
                    </div>`;
              cellClasses += ' is-2-liner';
              break;
            }
            case 'risk':
              cellContent = col.formatter(getNestedValue(asset, col.apiField));
              cellClasses += ' is-icon';
              break;
            case 'change_24h': {
              const changeValue = calculateChange24hValue(asset.price);
              cellContent = formatNullable(changeValue?.toFixed(2));
              if (changeValue > 0) cellClasses += ' is-positive';
              else if (changeValue < 0) cellClasses += ' is-negative';
              break;
            }
            case 'chart': // Скрыто
              // cellContent = `<button class="e-btn is-chart" type="button" ...></button>`;
              cellClasses += ' is-action';
              break;
            default: {
              const value = getNestedValue(asset, col.apiField);
              // --- DEBUGGING START ---
              if (!col.formatter) {
                console.error('Formatter is missing for column:', JSON.stringify(col));
                console.error('Asset data for this row:', JSON.stringify(asset));
                console.error('Value obtained by getNestedValue:', JSON.stringify(value));
              } else if (typeof col.formatter !== 'function') {
                console.error('col.formatter is not a function for column:', JSON.stringify(col));
                console.error('Type of col.formatter:', typeof col.formatter);
                console.error('Asset data for this row:', JSON.stringify(asset));
                console.error('Value obtained by getNestedValue:', JSON.stringify(value));
              }
              // --- DEBUGGING END ---
              cellContent = col.formatter
                ? col.formatter(value)
                : formatNullable(value);
              break;
            }
          }

          cellsHtml += `<td class="${cellClasses}" ${attributes}>${cellContent}</td>`;
        });

        // Добавляем data-* атрибуты и tabindex к строке
        return (
          `<tr data-asset-id="${asset.id}" data-asset-symbol="${
            asset.symbol
          }" tabindex="0" aria-label="${asset.name} - ${formatPrice(
            asset.price?.current
          )} USD" id="${rowId}">\n` +
          `    ${cellsHtml}\n` +
          '</tr>'
        );
      }

      // -----------------------------------------------------------------------
      // УТИЛИТЫ
      // -----------------------------------------------------------------------

      const throttle = (func, limit) => {
        let lastFunc;
        let lastRan;

        return function throttled(...args) {
          const context = this;

          if (!lastRan) {
            func.apply(context, args);
            lastRan = Date.now();
            return;
          }

          clearTimeout(lastFunc);
          lastFunc = setTimeout(
            () => {
              if (Date.now() - lastRan >= limit) {
                func.apply(context, args);
                lastRan = Date.now();
              }
            },
            limit - (Date.now() - lastRan)
          );
        };
      };

      function announceUpdate(message) {
        if (screenReaderAnnouncer) {
          screenReaderAnnouncer.textContent = message;
        }
      }

      // Add window unload handler for cleanup
      window.addEventListener('unload', cleanup);

      // -----------------------------------------------------------------------
      // ИНИЦИАЛИЗАЦИЯ
      // -----------------------------------------------------------------------
      const init = () => {
        try {
          if (!table || !scrollContainer || !tableBody || !tableHead) {
            // Добавлена проверка tableHead
            throw new Error('Required DOM elements not found');
          }

          // Заполнить чекбоксы колонок
          populateColumnCheckboxes();

          // Сгенерировать заголовки таблицы на основе видимых колонок
          generateTableHeadHtml();

          // sortButtons назначаются в generateTableHeadHtml, обработчики там же

          const throttledRender = throttle(renderTable, 100);
          scrollContainer.addEventListener('scroll', throttledRender);

          // Это вызовет processData -> applySortAndFilter -> renderTable
          fetchData();
          updateIntervalId = setInterval(fetchData, REFRESH_INTERVAL_MS);

          // Инициализировать счетчик фильтров
          updateFilterCountBadge();

          announceUpdate('{{ "Table loading."|trans|escape("js") }}');
        } catch (error) {
          if (IS_DEVELOPMENT) {
            console.error('Initialization failed:', error);
          }
          displayErrorState(
            '{{ "We couldn’t show the table. Something went wrong during setup."|trans|escape("js") }}'
          );
        }
      };

      document.addEventListener('DOMContentLoaded', init);
    })();
  </script>
{% endblock %}
